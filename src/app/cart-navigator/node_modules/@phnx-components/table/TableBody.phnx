/**
 * This is a template for view definition file in
 * Project Phoenix : UI-Creator
 */
module.exports = {
    name: "MTableBody",
    imports: [{
        type: "component",
        from: "./TableRow.phnx",
        take: "row"
    }],
    variables: [{
        name: "colStyle",
        type: "object",
        isMandatory: false,
        scope: "public"
    }, {
        name: "style",
        type: "object",
        isMandatory: true,
        scope: "public"
    }, {
        name: "rowStyle",
        type: "object",
        isMandatory: true,
        scope: "public"
    }, {
        name: "emitterData",
        type: "array",
        defaultValue: [],
        scope: "private"
    }, {
        name: "bodyData",
        type: "array",
        defaultValue: [],
        scope: "public"
    }, {
        name: "originData",
        type: "array",
        defaultValue: [],
        scope: "public"
    }, {
        name: "mappingData",
        type: "array",
        defaultValue: [],
        scope: "public"
    }, {
        name: "selectable",
        type: "boolean",
        isMandatory: true,
        scope: "public"
    }, {
        name: "byPass",
        type: "function",
        isMandatory: true,
        scope: "public"
    }, {
        name: "sortKey",
        type: "string",
        defaultValue: null,
        scope: "private"
    }, {
        name: "sortDirection",
        type: "number",
        defaultValue: 0,
        scope: "private"
    }, {
        name: "sorting",
        type: "object",
        isMandatory: true,
        scope: "public"
    }, {
        name: "searchString",
        type: "string",
        defaultValue: "",
        scope: "private"
    }, {
        name: "reflectionArray",
        type: "array",
        defaultValue: [],
        scope: "private"
    }, {
        name: "className",
        type: "string",
        isMandatory: true,
        scope: "public"
    }, {
        name: "rowClass",
        type: "string",
        isMandatory: true,
        scope: "public"
    }],
    functions: {
        searchBody: payload => {
            __utils__setPrivateVars({
                searchString: payload.data
            });
        },
        updateLocalParams: payload => {
            __utils__setPrivateVars({
                sortKey: payload.label,
                sortDirection: payload.direction
            });
        },
        sortRows: (a, b) => {
            let tempA, tempB;
            if (__var__sorting[__var__sortKey] == 'string') {
                tempA = a;
                tempB = b;
            } else if (__var__sorting[__var__sortKey] == 'number') {
                tempA = {};
                tempB = {};
                tempA[__var__sortKey] = parseInt(a[__var__sortKey]);
                tempB[__var__sortKey] = parseInt(b[__var__sortKey]);
            } else if (__var__sorting[__var__sortKey] == 'date') {
                tempA = {};
                tempB = {};
                tempA[__var__sortKey] = new Date(a[__var__sortKey]);
                tempB[__var__sortKey] = new Date(b[__var__sortKey]);
            } else if (typeof __var__sorting[__var__sortKey] == 'function') {
                return __var__sorting[__var__sortKey](a, b, __var__sortDirection);
            } else {
                return 0;
            }
            if (tempA[__var__sortKey] < tempB[__var__sortKey]) {
                return __var__sortDirection == 1 ? -1 : 1;
            } else if (tempA[__var__sortKey] > tempB[__var__sortKey]) {
                return __var__sortDirection == 1 ? 1 : -1;
            } else {
                return 0;
            }
        },
        filterHandler: instance => {
            const regex = new RegExp(__var__searchString, 'i');
            let flag;
            Object.keys(instance).forEach((item) => {
                if (regex.test(instance[item])) {
                    flag = true;
                }
            });
            return flag;
        },
        renderRows: () => {
            let renderArray;
            if (__var__sortKey !== null) {
                renderArray = __var__bodyData.sort(__fn__sortRows);
            } else {
                renderArray = __var__bodyData;
            }
            const reflectionArray = renderArray.filter(__fn__filterHandler);
            __utils__setPrivateVars({
                reflectionArray: reflectionArray
            }, false);
            return reflectionArray.map((item, index) => __tmpl__rowTemplate);
        },
        dataMapper: data => {
            const returnArray = Object.keys(__var__mappingData).map(item => {
                return data[item];
            });
            if (data.custom !== undefined) {
                returnArray.push({
                    type: 'custom',
                    value: data.custom
                });
            }
            return returnArray;
        }
    },
    eventHandlers: [{
        id: "emitSelection",
        from: {
            "row*": "selected"
        },
        workflow: ["emitSelection"]
    }],
    eventEmitters: [],
    localTemplates: {
        rowTemplate: {
            type: "__imports__row",
            id: "'row'+__fnParam__index",
            props: {
                position: "__fnParam__index",
                rowData: "__fn__dataMapper(__fnParam__item)",
                originData: "__var__originData",
                selectable: "__var__selectable",
                style: "Object.assign({},__var__rowStyle,{colStyle: __var__colStyle})",
                className: "__var__rowClass"
            }
        }
    },
    structure: {
        type: "tbody",
        props: {
            className: "__var__className",
            style: "__var__style"
        },
        children: ["__fn__renderRows()"]
    },
    lifecycleHooks: {
        init: {
            before: () => {
                __var__byPass.subscribe(x => {
                    switch (x.type) {
                        case 'search':
                            __fn__searchBody(x);
                            break;
                        case 'sort':
                            __fn__updateLocalParams(x);
                            break;
                        default:
                            break;
                    }
                },() => { //onError do something
                }, () => { //onComplete do something
                });
            }
        }
    },
    actions: [],
    workflows: {
        emitSelection: (eventObj, payload, properties) => {
            const updateEmitters = __var__emitterData;
            if (updateEmitters.indexOf(payload) > -1) {
                updateEmitters.splice(updateEmitters.indexOf(payload));
            } else {
                updateEmitters.push(payload);
            }
            __utils__setPrivateVars({
                emitterData: updateEmitters
            }, false, {
                concat: false
            });
            const finalPayload = {};
            updateEmitters.forEach((item) => {
                finalPayload['originalPosition'] = item;
                finalPayload['data'] = __var__reflectionArray[item];
            });
            __evt__updateSelection(eventObj, finalPayload, properties);
        }
    }
};