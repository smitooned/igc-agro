"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.doRequest = doRequest;
exports.doConnect = doConnect;
exports.doDisconnect = doDisconnect;
exports.doSend = doSend;
exports.phnxShouldUpdate = phnxShouldUpdate;
exports.workflowsInvocator = workflowsInvocator;
exports.getMyEvents = getMyEvents;
exports.targetVariables = targetVariables;
exports.runCallAction = runCallAction;
exports.runMyAction = runMyAction;
exports.applyDefaults = applyDefaults;
exports.applyProps = applyProps;
exports.getVariable = getVariable;
exports.makePropsCopy = makePropsCopy;
Object.defineProperty(exports, "DataConnector", {
  enumerable: true,
  get: function get() {
    return _index.default;
  }
});
exports.getStore = exports.getState = exports._makePayload = exports.takeFrom = exports.frameworkKeysToIgnore = void 0;

var _immutable = require("@phoenix/phnx-internal-utils/lib/immutable");

var userMsgs = _interopRequireWildcard(require("./userMessages"));

var _index = _interopRequireDefault(require("./data-connectors/index"));

var _configureStore = require("./store/configureStore");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var dataConnections = 'dataConnections';
var dispatch = _configureStore.configUtils.dispatch,
    getState = _configureStore.configUtils.getState,
    getStore = _configureStore.configUtils.getStore;
exports.getStore = getStore;
exports.getState = getState;
var frameworkKeysToIgnore = ['__passedDefaults', '__appName', '__passedProps', '__dontChange', '__otherModel', '__fetchedModel', '__appModel'];
/**
 * This function is used to resolve prefixes in the payload parsing
 * @param  {string}  evalString   The string with prefix
 * @return {string}               Parsed string
 */

exports.frameworkKeysToIgnore = frameworkKeysToIgnore;

function resolvePrefixes(evalString) {
  var ret_str = evalString;
  var isChanged = false;

  if (ret_str.search(/(__var__|__elId__|__prop__|__prePay__|__imports__)/) !== -1) {
    isChanged = true;
    ret_str = ret_str.replace(/__elId__/g, 'source.refs.');
    ret_str = ret_str.replace(/__var__(?:([A-Za-z0-9_]+)|\[([A-Za-z0-9_\'\"]+)\])/g, function (got, s1, s2) {
      if (s1 !== undefined) {
        return "getVariable.call(source, '".concat(s1, "')");
      }

      return "getVariable.call(source, ".concat(s2, ")");
    });
    ret_str = ret_str.replace(/(__imports__)/g, '');
    ret_str = ret_str.replace(/(__prop__)/g, 'source.props.');
    ret_str = ret_str.replace(/(__prePay__\b)/, 'prePayload');
    ret_str = ret_str.replace(/(__prePay__)/g, 'prePayload.');
  }

  if (isChanged) {
    return ret_str;
  }

  return "'" + ret_str + "'";
}
/**
 * Constructs an object with values from a source
 * @param  {object} source  the source object
 * @param  {object} takeObj the object which defines what to take from the source
 * @param prePayload
 * @return {object}         the final object with the collected values
 */


var takeFrom = function takeFrom(source, takeObj, prePayload) {
  var dataSource;
  var takenValue;

  function takeAsString(source, string) {
    return takeAsArray(source, [{
      what: string,
      as: string
    }]);
  }

  function takeAsObject(source, object) {
    return takeAsArray(source, [{
      what: object.what,
      as: object.as
    }]);
  }

  function getFromSource(source, what) {
    // expects source, source.props, prePayload in the closure
    var fromSource = eval(resolvePrefixes(what));

    if (fromSource === undefined) {
      console.warn(userMsgs.NOT_IN_SOURCE(what)); //eslint-disable-line
    }

    return fromSource;
  }

  function takeAsArray(source, array) {
    var payload = {};
    array.map(function (item) {
      var typeOfItem = Array.isArray(item) ? 'array' : _typeof(item);
      var typeMap = {
        object: function object() {
          return {
            name: item.as,
            value: getFromSource(source, item.what)
          };
        },
        string: function string() {
          return {
            name: item,
            value: getFromSource(source, item)
          };
        } // "array": // TODO: recurse for arrays?

      };
      var took = typeMap[typeOfItem]();

      if (took && took.value !== undefined) {
        payload[took.name] = took.value;
      } else {
        console.error(userMsgs.BAD_PAYLOAD(typeOfItem)); //eslint-disable-line
      }
    });
    return payload;
  }

  var typeOfTake = Array.isArray(takeObj) ? 'array' : _typeof(takeObj); // takeObj.take can be an object { what, as }, a string, an array of object&strings

  if (typeOfTake === 'string') {
    // if string and from is not specifed, then primitive
    takenValue = _defineProperty({}, takeObj, takeObj);
  } else {
    // is a string | object | array
    takenValue = {
      string: takeAsString,
      object: takeAsObject,
      array: takeAsArray
    }[typeOfTake](source, takeObj);
  }

  return takenValue;
};
/**
 * Takes a json that has a payload(array) attribute and makes a payload out of item
 * @return {object}      the constructed payload
 * @param source
 * @param payload
 * @param prePayload
 */


exports.takeFrom = takeFrom;

var _makePayload = function _makePayload(source, payload, prePayload) {
  var actualPayload;

  if (Array.isArray(payload)) {
    actualPayload = payload.map(function (takeObj) {
      return takeFrom(source, takeObj, prePayload);
    }).reduceRight(function (pload, cload) {
      return Object.assign(pload, cload);
    }, {}); // reduce form the right so that the ones that are declared later are persisted
  } else {
    // object or primitive
    // TODO: are you sure you want to allow objects?
    actualPayload = payload;
  }

  return actualPayload;
};

exports._makePayload = _makePayload;

function doRequest(connectionType, requestParams, callbacks, payload, properties) {
  return function (dispatch, getState) {
    var addOnURL = properties.addOnURL;

    var url = requestParams.url,
        headers = requestParams.headers,
        body = requestParams.body,
        otherRequestParams = _objectWithoutProperties(requestParams, ["url", "headers", "body"]);
    /*
     * headers can be potentially empty
     * will merge header from properties and reqParameters
     */


    headers = Object.assign(properties.headers || {}, headers || {});
    url += addOnURL || '';
    var connectionParams = {
      requestParams: _objectSpread({
        url: url,
        headers: headers,
        body: payload || body
      }, otherRequestParams),
      callbacks: callbacks
    };
    /* assuming here that DataConnector has been imported */

    var dataConnector = new _index.default(connectionType, connectionParams);
    dataConnector.start();
  };
}

function doConnect(connectionId, connectionType, requestParams, callbacks, pageName) {
  return function (dispatch, getState) {
    /* start making connectionParams */
    var connectionParams = {
      requestParams: requestParams,
      callbacks: callbacks
    };
    /* end of making connectionProperties */

    /* connect - this 'connection' carries the information of the connection */

    var dataConnector = new _index.default(connectionType, connectionParams);
    var connectionObj = dataConnector.dataConnector;
    dataConnector.start();
    var type = "".concat('UPDATE_' + pageName);
    var attrPath = [dataConnections, connectionId, 'dataConnector'];
    /* dispatch an action to persist the connection object */

    dispatch({
      type: type,
      attrPath: attrPath,
      value: connectionObj,
      properties: {}
    });
  };
}

function doDisconnect(connectionId, pageName) {
  return function (dispatch, getState) {
    var dataConnector = getState()[pageName][dataConnections][connectionId].dataConnector;
    var type = "".concat('UPDATE_' + pageName);
    var attrPath = [connectionId];

    if (dataConnector && dataConnector.isConnected) {
      dataConnector.end(); // when deleting, do not need value and properties

      dispatch({
        type: type,
        attrPath: attrPath,
        value: null
      });
    } else {
      console.warn(userMsgs.SOCKET_ALREADY_DISCONNECTED(name, pageName)); //eslint-disable-line
    }
  };
}

function doSend(connectionId, pageName, event, message) {
  var nameAndPage = "".concat(connectionId, "_").concat(pageName);
  return function (dispatch, getState) {
    var dataConnector = getState()[pageName][dataConnections][connectionId].dataConnector;

    if (dataConnector && dataConnector.isConnected) {
      dataConnector.sendMessage(event, message); // TODO: is there any use to this dispatch?

      dispatch({
        type: "".concat('SENT_MESSAGE_TO_SOCKET_' + nameAndPage)
      });
    } else {
      console.warn(userMsgs.UNABLE_TO_SEND_MESSAGE(name, pageName)); //eslint-disable-line

      dispatch({
        type: "".concat('UNABLE_TO_SEND_MESSAGE_' + nameAndPage)
      });
    }
  };
}

function phnxShouldUpdate(a, b) {
  //Basic fail-fast
  if (a === b) {
    return false;
  }

  if (a === null || _typeof(a) !== 'object' || b === null || _typeof(b) !== 'object') {
    return true;
  }

  var keyFilter = function keyFilter(item) {
    return frameworkKeysToIgnore.indexOf(item) === -1;
  };

  var aKeys = Object.keys(a).filter(keyFilter);
  var bKeys = Object.keys(b).filter(keyFilter); //Making sure the length is same

  if (aKeys.length !== bKeys.length) {
    return true;
  } //Making sure the keys are same
  //Checking for reference of root level stuff


  var staticVarsComparison = aKeys.some(function (item) {
    return bKeys.indexOf(item) === -1 || a[item] !== b[item];
  });
  var staticAndPassedPropsComparison;

  if (a.hasOwnProperty('__passedProps') && b.hasOwnProperty('__passedProps')) {
    staticAndPassedPropsComparison = phnxShouldUpdate(a.__passedProps, b.__passedProps) || staticVarsComparison;
  } else if (!b.hasOwnProperty('__passedProps') && !a.hasOwnProperty('__passedProps')) {
    staticAndPassedPropsComparison = staticVarsComparison;
  } else {
    return true;
  }

  if (a.hasOwnProperty('__appModel') && b.hasOwnProperty('__appModel')) {
    return phnxShouldUpdate(a.__appModel, b.__appModel) || staticAndPassedPropsComparison;
  } else if (!b.hasOwnProperty('__appModel') && !a.hasOwnProperty('__appModel')) {
    return staticAndPassedPropsComparison;
  } else {
    return true;
  }
}

function workflowsInvocator(wfs, eventObj, payload, properties) {
  var _this = this;

  wfs.forEach(function (wf) {
    if (typeof wf !== 'string' || typeof _this['wf_' + wf] !== 'function') {
      console.error('Expected workflow ' + wf + ' to be defined in workflows'); //eslint-disable-line
    }

    _this['wf_' + wf](eventObj, payload, properties);
  });
}

function triggerActions(invokeObj, eventName, eventObj, prePayLoad) {
  var _this2 = this;

  Object.keys(invokeObj).forEach(function (trigger) {
    /* assume that makePayload has been imported */
    var payload = _makePayload.call(null, _this2, invokeObj[trigger] && invokeObj[trigger].payload, prePayLoad); // need to invoke the trigger method with the constructed payload and properties


    var properties = invokeObj[trigger] && invokeObj[trigger].properties || {};
    Object.keys(properties).forEach(function (key) {
      if (typeof properties[key] === 'function') {
        properties[key] = properties[key].apply(null, [payload, eventObj]);
      }

      if ((key === 'erase' || key === 'concat' || key === 'shouldUpdate') && typeof properties[key] !== 'boolean') {
        console.error(userMsgs.WRONG_PROPERTIES(_this2.constructor.phnxCompName, eventName, key)); //eslint-disable-line
      }
    });
    typeof _this2.props[trigger] === 'function' && _this2.props[trigger](eventObj, payload, properties);
  });
}

function getMyEvents(ref, phnxEventMap) {
  var _this3 = this;

  var finalRet;

  if (this.__finalEventMap[ref]) {
    finalRet = this.__finalEventMap[ref];
  } else {
    var toReturn = {};
    var elems = Object.keys(phnxEventMap);
    var toApply = elems.filter(function (item) {
      var result;

      if (/\*$/.test(item)) {
        item = item.replace(/\*$/, '.*');
        result = new RegExp('^' + item).test(ref);
      } else {
        result = item === ref;
      }

      return result;
    }).sort(); //returns ["but*", "butt*", "button*", "button1"]

    toApply.forEach(function (item) {
      var elMap = phnxEventMap[item];
      Object.keys(elMap).forEach(function (evtName) {
        if (elMap[evtName].type === 'wf') {
          toReturn[evtName] = workflowsInvocator.bind(_this3, elMap[evtName].value);
        } else if (elMap[evtName].type === 'evt') {
          toReturn[evtName] = triggerActions.bind(_this3, elMap[evtName].value, evtName);
        }
      });
    });
    this.__finalEventMap[ref] = toReturn;
    finalRet = toReturn;
  }

  if (this.__userAddedEvents[ref]) {
    return Object.assign({}, this.__userAddedEvents[ref], finalRet);
  } else {
    return finalRet;
  }
}

function makeCall(actionId, callObj, payload, properties, eventObj) {
  var parameters = [payload, eventObj];
  var payloadModifier = callObj.payloadModifier,
      actionProps = callObj.actionProps,
      asyncAction = callObj.asyncAction,
      callbacks = callObj.callbacks;
  var value;
  var pageName = this.constructor.phnxCompName;

  if (typeof payloadModifier === 'function') {
    value = payloadModifier.apply(null, parameters);

    if (!value) {
      // TODO: payloadModifier of actionName - are you sure?
      console.warn(userMsgs.NULL_PAYLOAD_ACTION(pageName, actionId)); //eslint-disable-line
    }
  } else {
    value = payload;
  }
  /* preference given to the Actions' properties */


  var thisProps = actionProps || properties;
  Object.keys(thisProps).forEach(function (key) {
    if (typeof thisProps[key] === 'function') {
      thisProps[key] = thisProps[key].apply(null, parameters);
    }

    if ((key === 'erase' || key === 'concat' || key === 'shouldUpdate') && typeof thisProps[key] !== 'boolean') {
      console.error(userMsgs.WRONG_PROPERTIES(pageName, actionId, key)); //eslint-disable-line
    }
  });
  /* preference given to the concat from properties, defaults to true */

  thisProps.concat = thisProps.hasOwnProperty('concat') ? thisProps.concat : true;
  thisProps.erase = thisProps.hasOwnProperty('erase') ? thisProps.erase : false;
  /* need to invoke the action creator that will call some connection api */

  dispatch(asyncAction(callbacks, value, thisProps, this));
}

function targetVariables(actionId, varToFnMap, payload, properties, eventObj) {
  var _this4 = this;

  var parameters = [payload, eventObj];
  var appName = this.props.__appName;
  var pageName = this.constructor.phnxCompName;
  var actions = varToFnMap.map(function (_ref) {
    var targetScope = _ref.targetScope,
        attrPath = _ref.attrPath,
        payloadModifier = _ref.payloadModifier,
        actionProps = _ref.actionProps;
    var value;

    if (typeof payloadModifier === 'function') {
      value = payloadModifier.apply(null, parameters);

      if (value === undefined || value === null) {
        console.warn(userMsgs.NULL_PAYLOAD_EVT(pageName, attrPath, actionId)); //eslint-disable-line
      }
    } else {
      value = payload;
    }
    /* preference given to the Actions' properties */


    var thisProps = actionProps || properties;
    Object.keys(thisProps).forEach(function (key) {
      if (typeof thisProps[key] === 'function') {
        thisProps[key] = thisProps[key].apply(null, parameters);
      }

      if ((key === 'erase' || key === 'concat' || key === 'shouldUpdate') && typeof thisProps[key] !== 'boolean') {
        console.error(userMsgs.WRONG_PROPERTIES(pageName, actionId, key)); //eslint-disable-line
      }
    });
    thisProps.concat = typeof thisProps.concat === 'boolean' ? thisProps.concat : true;
    thisProps.shouldUpdate = typeof thisProps.shouldUpdate === 'boolean' ? thisProps.shouldUpdate : true;

    if (!thisProps.shouldUpdate) {
      return {
        type: 'SKIP_THIS'
      };
    }

    thisProps = Object.assign(thisProps, {
      __component: pageName,
      __actionName: actionId
    });

    switch (targetScope) {
      case 'otherModel':
        return {
          type: "".concat('UPDATE_' + attrPath[0]),
          attrPath: attrPath.slice(1),
          value: value,
          properties: thisProps
        };

      case 'appModel':
        return {
          type: "".concat('UPDATE_' + appName),
          attrPath: attrPath,
          value: value,
          properties: thisProps
        };

      case 'var':
        if (_this4.varTypeMap[attrPath[0]].scope !== 'model') {
          console.error('Targets is to update the model variable only!'); //eslint-disable-line
        }

        return {
          type: "".concat('UPDATE_' + pageName),
          attrPath: attrPath,
          value: value,
          properties: thisProps
        };

      default:
        console.warn(userMsgs.INVALID_PREFIX(targetScope, pageName)); //eslint-disable-line

        break;
    }
  });
  dispatch({
    type: 'BATCH_ACTIONS',
    actions: actions
  });
}

function runCallAction(actionObj, actionId, eventObj, payload, properties) {
  var _this5 = this;

  var actionWhat = actionObj.what.replace(/^__dConn__/g, '').split('.');

  if (actionWhat.length !== 2) {
    console.error("The syntax for calling a DataConnection \"DConnID.API\" is not followed");
    return;
  }

  var functionName = actionWhat[0];
  var API = actionWhat[1];
  var response = actionObj.response || {};
  var callbacks = {};
  Object.keys(response).forEach(function (item) {
    callbacks[item] = function (dataFromSource) {
      workflowsInvocator.call(_this5, response[item], eventObj, dataFromSource);
    };
  });

  var actionFn = getState()[this.props.__appName].dataConnections[functionName][API];

  if (typeof actionFn !== 'function') {
    console.error("Data connection ".concat(functionName, " should be defined in the app")); //eslint-disable-line

    return;
  }

  var callObj = {
    asyncAction: actionFn,
    payloadModifier: actionObj.body,
    actionProps: actionObj.properties,
    callbacks: callbacks
  }; //FUTURE: Bring in responseTimeout, retries

  makeCall.call(this, actionId, callObj, payload, properties, eventObj);
}

function runMyAction(actionId, eventObj, payload, properties) {
  properties = properties || {};
  var actionObj = this.__actionMap[actionId];

  if (actionObj.type === 'CALL') {
    module.exports.runCallAction.call(this, actionObj, actionId, eventObj, payload, properties);
  } else if (actionObj.type === 'TARGETS') {
    var targets = actionObj.update;
    var varToFnMap = Object.keys(targets).map(function (variable) {
      var _targets$variable = targets[variable],
          payloadModifier = _targets$variable.payloadModifier,
          properties = _targets$variable.properties;
      var targetScope = variable.split('__')[1];
      var attrPath = variable.replace(/^(__var__|__appModel__|__otherModel__)/, '').split('.');

      if (targetScope === 'otherModel') {
        attrPath[0] = attrPath[0].charAt(0).toUpperCase() + attrPath[0].substr(1);
      }

      return {
        targetScope: targetScope,
        attrPath: attrPath,
        payloadModifier: payloadModifier,
        actionProps: properties
      };
    });
    targetVariables.call(this, actionId, varToFnMap, payload, properties, eventObj);
  } //Don't need to write an else since validation done by expect structure

}

function applyDefaults() {
  var shouldUpdate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  var localVars = Object.assign({}, this.__compDefaults);

  if (this.props.__passedDefaults) {
    localVars = useVarMergeProps.call(this, localVars, this.props.__passedDefaults);
  }

  this.__localVars = localVars;

  if (shouldUpdate) {
    this.forceUpdate();
  }
}

function applyProps(newProps) {
  var _this6 = this;

  var localProps, toMerge;

  if (newProps) {
    //Take a diff and push only those changes here
    localProps = this.__localProps;
    toMerge = getMeChanged(this.props.__passedProps, newProps.__passedProps);

    if (this.props.__dontChange && this.props.__dontChange.indexOf('__allPropsChange') === -1) {
      Object.keys(toMerge).forEach(function (item) {
        if (_this6.props.__dontChange.indexOf(item) === -1) delete toMerge[item];
      });
    }

    if (newProps.__fetchedModel) {
      var changedModel = getMeChanged(this.props.__fetchedModel, newProps.__fetchedModel);
      toMerge = Object.assign(toMerge, changedModel);
    }
  } else {
    localProps = Object.assign({}, this.__compPropDefaults);
    toMerge = this.props.__passedProps;

    if (toMerge && this.props.__fetchedModel) {
      toMerge = Object.assign(toMerge, this.props.__fetchedModel);
    }
  }

  if (toMerge) {
    localProps = useVarMergeProps.call(this, localProps, toMerge);
  }

  this.__localProps = localProps;
}

function useVarMergeProps(original, toMerge) {
  var _this7 = this;

  var toReturn = original;
  Object.keys(toMerge).forEach(function (varName) {
    if (!_this7.varTypeMap[varName]) {
      return;
    }

    var mergeProps = _this7.varTypeMap[varName].mergeProps;
    var erase = mergeProps.hasOwnProperty('erase') ? mergeProps.erase : true;
    toReturn = (0, _immutable.mergeDeepKeepLeft)(toReturn, _defineProperty({}, varName, toMerge[varName]), {
      erase: erase,
      concat: false
    });
  });
  return toReturn;
}

function getMeChanged(old, new1) {
  if (new1 === null || _typeof(new1) !== 'object') return {};
  if ((old === null || _typeof(old) !== 'object') && new1 !== null && _typeof(new1) === 'object') return new1;
  var oldKeys = Object.keys(old);
  var newKeys = Object.keys(new1);
  var toReturn = {};
  newKeys.forEach(function (item) {
    if (oldKeys.indexOf(item) === -1 || old[item] !== new1[item]) {
      toReturn[item] = new1[item];
    }
  });
  return toReturn;
}

function getVariable(name) {
  var toReturn = '';

  if (this.varTypeMap[name] === undefined) {
    console.error('The variable ' + name + ' is not defined in variables'); //eslint-disable-line
  }

  switch (this.varTypeMap[name].scope) {
    case 'public':
      toReturn = this.__localProps[name];
      break;

    case 'private':
      toReturn = this.__localVars[name];
      break;

    case 'protected':
      toReturn = this.context[name];
      break;

    case 'model':
      toReturn = this.props[name];
      break;

    default:
      break;
  }

  return toReturn;
}
/**
 * Merges the values of props, fetchecProps and passedProps
 * @param  {object} newProps the new props to the component
 * @return {object}          copied object
 */


function makePropsCopy(newProps) {
  // FUTURE: remove functions from this copied object?
  var copiedProps = Object.assign({}, newProps, newProps.__passedProps, newProps.__fetchedModel); // what else do we delete from copiedProps?

  delete copiedProps.__fetchedModel;
  delete copiedProps.__passedProps;
  return copiedProps;
}