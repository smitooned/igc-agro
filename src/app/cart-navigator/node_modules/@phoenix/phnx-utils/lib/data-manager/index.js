"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = makeReducerInState;

var _configureStore = require("../store/configureStore");

var _reducers = _interopRequireDefault(require("../reducers"));

var _reducerTemplate = _interopRequireDefault(require("../reducerTemplate"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A set of APIs to
 * 1. make a reducer in the state with some initial state
 * 2. make actions that facilitate connection with a data source (async actions)
 * @author: raghudevan.s@mu-sigma.com, sandhya.paul@mu-sigma.com
 * @date: Aug-Sep, 2016
 */
// imports that are needed to make a reducer

/**
 * Makes a reducer in the state with the pageName; the reducer is initialised with
 * the variables (set to their default values)
 * @param  {string} pageName      name of the page that is also given to the reducer
 * @param  {object} variablesUsed an object mapping the names of variables used to their default values
 */
function makeReducerInState(pageName, variablesUsed) {
  // make the reducer - there is only one reducer per page
  var initialState = {}; // variablesUsed should be an object { varName: defaultValue }

  Object.keys(variablesUsed).forEach(function (varName) {
    initialState[varName] = variablesUsed[varName];
  });
  var reducer = (0, _reducerTemplate.default)(initialState, pageName);

  _configureStore.configUtils.replaceReducer((0, _reducers.default)({
    reducerName: pageName,
    reducer: enableBatching(reducer)
  }));
}
/**
 * This function allows for the batched actions (an array of actions) to get dispatched into store in a single call
 * @param  {function} reducer The actual reducer function
 * @return {function}         The wrapped function to enable batching
 */


function enableBatching(reducer) {
  return function batchingReducer(state, action) {
    //Added since for type __var__ where variable is not model, action will be null
    if (action && action.type) {
      switch (action.type) {
        case 'BATCH_ACTIONS':
          return action.actions.reduce(batchingReducer, state);

        default:
          return reducer(state, action);
      }
    } else {
      return state;
    }
  };
}