"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.doModelUpdate = doModelUpdate;
exports.getComponentProperties = getComponentProperties;
exports.getComponentAPInEvents = getComponentAPInEvents;
exports.resetComponentDefaults = resetComponentDefaults;
exports.setPrivateVars = setPrivateVars;
exports.setPublicVars = setPublicVars;
exports.mapDefVarNames = mapDefVarNames;
exports.reApplyDefaults = reApplyDefaults;
exports.getComponentByRef = getComponentByRef;
exports.addDynamicEvents = addDynamicEvents;
exports.emitEvent = emitEvent;
exports.getChangedExtVars = getChangedExtVars;
exports.getChangedModelVars = getChangedModelVars;
exports.getPrivateVars = getPrivateVars;
exports.getModelVars = getModelVars;
exports.getPublicVars = getPublicVars;
exports.getProtectedVars = getProtectedVars;
exports.isConnectionAlive = isConnectionAlive;
Object.defineProperty(exports, "navigateTo", {
  enumerable: true,
  get: function get() {
    return _index2.navigateTo;
  }
});
Object.defineProperty(exports, "RouteLink", {
  enumerable: true,
  get: function get() {
    return _index2.RouteLink;
  }
});
exports.ObjectUtils = void 0;

var _immutable = require("@phoenix/phnx-internal-utils/lib/immutable");

var secret_utils = _interopRequireWildcard(require("../index.js"));

var ObjectUtils = _interopRequireWildcard(require("./objectUtils"));

exports.ObjectUtils = ObjectUtils;

var _configureStore = require("../store/configureStore");

var _index2 = require("../dynamic-routing/index");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * This function will handle making a dynamic variable update
 * @param  {object} config     Contains all the info about the variable to be updated
 * @param  {object} eventObj   Event object
 * @param  {object} payload    Payload for the event
 * @param  {object} properties Properties for making the update
 */
function doModelUpdate(config, eventObj, payload, properties) {
  properties = properties || {};

  if (typeof config.type !== 'string' || typeof config.path !== 'string') {
    throw new Error('The type and path has to be a string similar to how you would write it in TARGETS action');
  } //Can change this back to __var__blah.blah once ast is implemented correctly


  var targetScope = config.type;
  var attrPath = config.path.split('.');

  if (targetScope === 'otherModel') {
    attrPath[0] = attrPath[0].charAt(0).toUpperCase() + attrPath[0].substr(1);
  }

  var varToFnMap = [{
    targetScope: targetScope,
    attrPath: attrPath,
    payloadModifier: config.payloadModifier || null,
    actionProps: null
  }];
  secret_utils.targetVariables.call(this, 'DynamicUpdate', varToFnMap, payload, properties, eventObj);
}

function getComponentProperties(ref) {
  if (ref === null) {
    return {
      metadata: this.constructor.metadata,
      publicDefaults: this.__compPropDefaults
    };
  } else if (typeof ref === 'string' && this.refs.hasOwnProperty(ref) && this.refs[ref].wrappedInstance && this.refs[ref].wrappedInstance.constructor.phnxCompName !== undefined) {
    if (/^Connect/.test(this.refs[ref].constructor.displayName)) {
      return {
        metadata: this.refs[ref].wrappedInstance.constructor.metadata,
        publicDefaults: this.refs[ref].wrappedInstance.__compPropDefaults
      };
    } else {
      console.error('Some element is Non Connected. How?????');
    }
  } else {
    throw new Error('Invalid component ID specified in ' + this.constructor.phnxCompName);
  }
}

function getComponentAPInEvents(ref) {
  if (ref === null) {
    return {
      apis: this.constructor.apis,
      events: this.constructor.events
    };
  } else if (typeof ref === 'string' && this.refs.hasOwnProperty(ref) && this.refs[ref].wrappedInstance && this.refs[ref].wrappedInstance.constructor.phnxCompName !== undefined) {
    if (/^Connect/.test(this.refs[ref].constructor.displayName)) {
      return {
        apis: this.refs[ref].wrappedInstance.constructor.apis,
        events: this.refs[ref].wrappedInstance.constructor.events
      };
    } else {
      console.error('Some element is Non Connected. How?????');
    }
  } else {
    throw new Error('Invalid component ID specified in ' + this.constructor.phnxCompName);
  }
}

function resetComponentDefaults() {
  this.__localVars = this.__compDefaults;
}

function setPrivateVars(payload, shouldUpdate) {
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref$erase = _ref.erase,
      erase = _ref$erase === void 0 ? false : _ref$erase,
      _ref$concat = _ref.concat,
      concat = _ref$concat === void 0 ? true : _ref$concat;

  shouldUpdate = typeof shouldUpdate === 'boolean' ? shouldUpdate : true;
  this.__localVars = (0, _immutable.mergeDeepKeepLeft)(this.__localVars, payload, {
    erase: erase,
    concat: concat
  });

  if (shouldUpdate) {
    this.forceUpdate();
  }
}

function setPublicVars(payload) {
  var _this = this;

  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref2$erase = _ref2.erase,
      erase = _ref2$erase === void 0 ? false : _ref2$erase,
      _ref2$concat = _ref2.concat,
      concat = _ref2$concat === void 0 ? true : _ref2$concat;

  if (this.props.__dontChange && this.props.__dontChange.length > 0) {
    if (this.props.__dontChange.indexOf('__allPropsChange') !== -1) {
      console.warn('Cannot change any of the external properties using setPublicVars call in the view ' + this.constructor.phnxCompName); //eslint-disable-line

      return;
    } else if (Object.keys(payload).some(function (item) {
      return _this.props.__dontChange.indexOf(item) !== -1;
    })) {
      console.warn("Won't update changes to any of (".concat(this.props.__dontChange.toString(), ") in the view ").concat(this.constructor.phnxCompName)); //eslint-disable-line

      this.props.__dontChange.forEach(function (item) {
        return delete payload[item];
      });

      if (Object.keys(payload).length === 0) return;
    }
  }

  this.__localProps = (0, _immutable.mergeDeepKeepLeft)(this.__localProps, payload, {
    erase: erase,
    concat: concat
  });
  this.forceUpdate();
}

function mapDefVarNames(name) {
  return this.constructor.finalDefVarMap[name];
}

function reApplyDefaults(ref) {
  if (ref === null) {
    secret_utils.applyDefaults.call(this, true);
  } else if (typeof ref === 'string' && this.refs.hasOwnProperty(ref) && this.refs[ref].wrappedInstance && this.refs[ref].wrappedInstance.constructor.phnxCompName !== undefined) {
    if (/^Connect/.test(this.refs[ref].constructor.displayName)) {
      secret_utils.applyDefaults.call(this.refs[ref].wrappedInstance, true);
    } else {
      console.error('Some element is Non Connected. How?????');
    }
  } else {
    throw new Error('Invalid component ID specified in ' + this.constructor.phnxCompName);
  }
}

function getComponentByRef(ref) {
  if (this.refs.hasOwnProperty(ref)) {
    var comp = this.refs[ref];

    if (comp.constructor.name === 'LoadableComponent') {
      if (comp.state.loading === true) {
        throw new Error("The component is still being loaded, you cannot use this component's APIs in init lifecycle. If you still want to use this, you can disable lazyLoad of this component with ID " + ref);
      }

      return comp.refs.__innerInstance.getWrappedInstance();
    } else if (comp.getWrappedInstance) {
      return comp.getWrappedInstance();
    }

    return comp;
  } else {
    console.warn("unable to retrieve component[".concat(ref, "] by ref in ").concat(this.constructor.phnxCompName)); //eslint-disable-line
  }
}

function addDynamicEvents(ref, eventMap) {
  Object.keys(eventMap).forEach(function (item) {
    if (typeof eventMap[item] !== 'function') {
      throw new Error("Event Map contains a non function on ".concat(item, " attribute"));
    }
  });
  delete this.__userAddedEvents[ref];
  this.__userAddedEvents[ref] = eventMap;
}

function emitEvent(name, eventObj, payload, properties) {
  if (this.props[name] && typeof this.props[name] === 'function') {
    this.props[name](eventObj, payload, properties);
  }
}

function getChangedExtVars(nextProps) {
  if (nextProps === null || _typeof(nextProps) !== 'object') {
    return console.warn('New external variables supplied to the function is improper'); //eslint-disable-line
  }

  return ObjectUtils.shallowObjDiff(this.props.__passedProps, nextProps.__passedProps);
}

function getChangedModelVars(nextProps) {
  if (nextProps === null || _typeof(nextProps) !== 'object') {
    return console.warn('New external variables supplied to the function is improper'); //eslint-disable-line
  }

  return ObjectUtils.shallowObjDiff(this.props, nextProps);
}
/**
 * Retrieves the private variables of a component class
 * @return {any} value of the variable
 */


function getPrivateVars() {
  return this.__localVars;
}
/**
 * Retrieves the model variables of a component class
 * @return {any} value of the variable
 */


function getModelVars() {
  return _configureStore.configUtils.getState()[this.constructor.phnxCompName];
}
/**
 * Retrieves the public variables of a component class
 * @return {any} value of the variable
 */


function getPublicVars() {
  return this.__localProps;
}
/**
 * Retrieves the protected variables of a component class
 * @return {any} value of the variable
 */


function getProtectedVars() {
  return this.context;
}
/**
 * Returns a boolean denoting connection status
 * @return {boolean} connection status
 */


function isConnectionAlive(connectionId) {
  var dataConnector = _configureStore.configUtils.getState()[this.props.__appName].dataConnections[connectionId].dataConnector;

  return dataConnector ? dataConnector.isConnected : false;
}