"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * A class that enables making REST calls
 * @author: sandhya.paul@mu-sigma.com, raghudevan.s@mu-sigma.com
 * @date: Aug, 2016
 */
var constReadOrder = {
  // TODO: blob, arrayBuffer can be read as text
  order: ['json', 'text', 'blob'],
  index: 0
};
/**
 * This function returns a Promise .The promise when resolved gives the response body in desired format
 * he promise when resolved gives the error
 * @param  {string} url     url to be resolved
 * @param  {object} options An object with expected response Type etc
 * @return {Promise}        Promise Object that is resolved with the given value
 */

function request(url, options) {
  // options { method, headers, body }
  // mutate the body as per the Content-Type
  if (options.headers && options.headers['Content-Type'] === 'application/x-www-form-urlencoded') {
    // need to make a form
    var encode = function encode(value) {
      return encodeURIComponent(value);
    };

    options.body = Object.keys(options.body).map(function (formItem) {
      return encode(formItem) + '=' + encode(options.body[formItem]);
    }).join('&');
  } else if (options.headers && /form-data$/.test(options.headers['Content-Type'])) {
    var formData = new FormData();

    for (var key in options.body) {
      if (Array.isArray(options.body[key])) {
        options.body[key].forEach(function (item) {
          return formData.append(key, item);
        });
      } else {
        formData.append(key, options.body[key]);
      }
    }

    options.body = formData;
    delete options.headers['Content-Type'];
  } else {
    options.body = JSON.stringify(options.body);
  }

  return new Promise(function (resolve, reject) {
    fetch(url, options).then(function (responseBody) {
      if (responseBody.status >= 400) {
        var readOrder = Object.assign({}, constReadOrder);
        dataChecks(responseBody, readOrder, reject, reject, {
          errMessage: 'Not in any recognizable format'
        });
      } else {
        // responseType - can only be one of [json, text, blob, arrayBuffer]
        // - what about file stream - what type of response is that?
        try {
          var _readOrder = Object.assign({}, constReadOrder);

          if (options.responseType) {
            // mutate readOrder with the correct index
            _readOrder.index = _readOrder.order.indexOf(options.responseType);
          }

          dataChecks(responseBody, _readOrder, resolve, reject, {
            errMessage: 'Not in any recognizable format'
          });
        } catch (e) {
          // something went wrong here - mostly responseType was wrong
          reject({
            errMessage: e.toString() + ' where responseType is ' + options.responseType
          });
        }
      }
    }).catch(function (err) {
      return reject(err);
    });
  });
} // responseBody is a promise


function dataChecks(responseBody, readOrder, resolve, reject, rejectionMessage) {
  var responseClone = responseBody.clone();

  if (readOrder.index === -1) {
    throw new Error("options.responseType has to be one of [".concat(constReadOrder.order, "]"));
  }

  var responseType = readOrder.order[readOrder.index];
  responseBody[responseType]().then(function (response) {
    resolve(response);
  }).catch(function (err) {
    readOrder.index += 1;

    if (readOrder.index > readOrder.order.length - 1) {
      reject(rejectionMessage);
    } else {
      dataChecks(responseClone, readOrder, resolve, reject, rejectionMessage);
    }
  });
}

var Rest =
/*#__PURE__*/
function () {
  function Rest(requestParams) {
    var _this = this;

    _classCallCheck(this, Rest);

    Object.defineProperty(this, "connect", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: function value() {
        var _this$requestParams = _this.requestParams,
            url = _this$requestParams.url,
            options = _objectWithoutProperties(_this$requestParams, ["url"]);

        _this.connectionObj = request(url, options);
        return _this;
      }
    });
    Object.defineProperty(this, "sendMessage", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: function value() {
        /* not needed in the context of REST */
      }
    });
    Object.defineProperty(this, "disconnect", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: function value() {
        /* not needed in the context of REST */
      }
    });
    this.requestParams = requestParams;
  }
  /**
   * Make a connection
   * @param  {object} requestParams Params for request
   * @param  {body}   body          body for request
   * @return {promise}              the connection object
   */


  _createClass(Rest, [{
    key: "registerCallbacks",

    /**
     * This function is used for registering the call on success and failures
     * @param  {promise} conObj     The promise which wraps fetch
     * @param  {object} properties  Object containing callBacks
     * @return {promise}            the connection object
     */
    value: function registerCallbacks(callbacks) {
      this.connectionObj.then(function (formattedResponseBody) {
        if (!formattedResponseBody.__phnxTestStubFlag) {
          callbacks.successCallBack ? callbacks.successCallBack(formattedResponseBody) : null;
        }
      }, function (err) {
        // invoke the failure callbacks with the error
        callbacks.failureCallBack ? callbacks.failureCallBack(err) : null;
      });
      return this;
    }
  }]);

  return Rest;
}();

exports.default = Rest;