"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.convertSearchToQuery = convertSearchToQuery;
exports.getItemsFromLocation = getItemsFromLocation;
exports._getFromState = _getFromState;
exports._addStaticRoutes = _addStaticRoutes;
exports._routeApp = _routeApp;
exports._setNavObj = _setNavObj;
exports.navigateTo = navigateTo;
exports.initializeStore = initializeStore;
exports.default = initializeApp;
exports.RouteLink = void 0;

var _react = _interopRequireDefault(require("react"));

var _reactRedux = require("react-redux");

var _reactHotLoader = require("react-hot-loader");

var _reactRouter = require("react-router");

var _reactRouterDom = require("react-router-dom");

var _phnxUtils = require("@phoenix/phnx-utils");

var _configureStore = _interopRequireWildcard(require("../store/configureStore"));

var _dataManager = _interopRequireDefault(require("../data-manager"));

var _RouteTemplate = _interopRequireDefault(require("./RouteTemplate"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var ROUTES_CONFIG = 'routesConfig';
var NAV_OBJ = 'navObj';
var appName;
var browserHistory;

function convertQueryToSearch(query) {
  var searches = Object.keys(query).map(function (queryName) {
    var queryValue = String(query[queryName]);
    return "".concat(queryName, "=").concat(queryValue);
  });
  return "?".concat(searches.join('&'));
}

function convertSearchToQuery(search) {
  var query = {};
  search.replace(/^\?/, '').split('&').reduce(function (query, next) {
    if (next.trim() !== '') {
      var keyValue = next.split('=');
      var key = keyValue[0];
      var value = keyValue[1];
      query[key] = value;
    }

    return query;
  }, query);
  return query;
}

function getItemsFromLocation(locationToGetFrom) {
  var host = locationToGetFrom.host,
      hostname = locationToGetFrom.hostname,
      href = locationToGetFrom.href,
      origin = locationToGetFrom.origin,
      pathname = locationToGetFrom.pathname,
      port = locationToGetFrom.port,
      protocol = locationToGetFrom.protocol,
      search = locationToGetFrom.search;
  return {
    host: host,
    hostname: hostname,
    href: href,
    origin: origin,
    pathname: pathname,
    port: port,
    protocol: protocol,
    search: search
  };
}
/**
 * Retrieves some value from the part of the state where
 * we keep application related variables, based on the attrPath
 * @param  {string} appName application name
 * @param  {string} attr    name of the attribute to retrieve
 * @return {any}            value of the attribute in the state
 */


function _getFromState(appName, attr) {
  var value = _configureStore.configUtils.getState()[appName][attr];

  return value;
}
/**
 * Creates an array of routes based on the routesConfig array
 * @param {string}  name         page/app name
 * @param {array}   routesConfig an array of objects describing the routes
 */


function _addStaticRoutes(name, routesConfig) {
  var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '/';
  var routesToAppend = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
  var routes = routesConfig.map(function (routeObject, index) {
    var componentProps = {
      routeObject: routeObject,
      __appName: appName,
      getRoutes: _getFromState.bind(null, appName, ROUTES_CONFIG),
      getNavObj: _getFromState.bind(null, appName, NAV_OBJ),
      setNavObj: _setNavObj.bind(null, appName)
    };

    var onEnter = function onEnter(nextRoute) {
      var appModel = _configureStore.configUtils.getState()[appName];

      try {
        var query = convertSearchToQuery(nextRoute.location.search);

        var _routeObject$onEnter = routeObject.onEnter(appModel, {
          location: getItemsFromLocation(nextRoute.location)
        }),
            userPath = _routeObject$onEnter.path,
            userQuery = _routeObject$onEnter.query; //It has to returns an object which can have {path, query} attrs


        if (typeof userPath === 'string') {
          if (userQuery) {
            query = userQuery;
          }

          if (userPath !== nextRoute.location.pathname) {
            var search = convertQueryToSearch(query);
            var newPath = userPath + search;
            browserHistory.replace(newPath);
            return newPath;
          }
        } else if (userPath !== null) {
          console.warn("The return object from the onEnter of ".concat(routeObject.name, " is not as per standards")); //eslint-disable-line
        } // path = null -> go ahead and allow enter of hook

      } catch (e) {
        console.warn("The onEnter of ".concat(routeObject.name, " threw an error"), e); //eslint-disable-line
      }
    };

    var functionsToSpread = {
      onEnter: routeObject.onEnter ? onEnter : undefined
    }; // regularize the path

    var routePath = (path + routeObject.url).replace(/^\/*(.*)/g, '/$1').replace(/(^.+)\/*$/g, '$1').replace(/\/+/g, '/');
    var isExact = true;

    if (Array.isArray(routeObject.routes) && routeObject.routes.length) {
      // if a route has children, then its path must be a non-exact match
      // only then will it match for it's children's paths
      isExact = false;
      routeObject.routeContent = _addStaticRoutes(name, routeObject.routes, routePath, routesToAppend);
    }

    var Component = function Component(props) {
      return _react.default.createElement(_RouteTemplate.default, _extends({}, props, componentProps, functionsToSpread));
    };

    var route = _react.default.createElement(_reactRouterDom.Route, {
      exact: isExact,
      path: routePath,
      component: Component,
      key: index
    });

    return route;
  });
  Array.prototype.push.apply(routes, routesToAppend);
  return _react.default.createElement(_reactRouterDom.Switch, {
    className: 'router-switch'
  }, routes);
}
/**
 * Creates the root Router for the application
 * @param  {string} appName      application name
 * @param  {object} store        application store
 * @param  {array} routesConfig  application routes configuration object
 * @return {element}             a react-router Router element
 */


function _routeApp(appName, basename, store, routesConfig) {
  var fallbackPage = function fallbackPage() {
    return _react.default.createElement("div", null, "404 Page not found");
  };

  var NotFoundPage = _react.default.createElement(_reactRouterDom.Route, {
    path: "*",
    component: fallbackPage,
    key: "fallback-page"
  });

  var routes = _addStaticRoutes(appName, routesConfig, '/', [NotFoundPage]);

  var routerChildren = _react.default.createElement((0, _reactRouter.withRouter)(function (_ref) {
    var history = _ref.history;
    browserHistory = history;
    return _react.default.createElement('div', {
      className: 'phnx-app-container',
      style: {
        height: '100%',
        width: '100%'
      }
    }, routes);
  }));

  var app = _react.default.createElement(_reactRouterDom.BrowserRouter, {
    basename: basename
  }, routerChildren);

  var provider = _react.default.createElement(_reactRedux.Provider, {
    store: store
  }, app);

  var appContainer = _react.default.createElement(_reactHotLoader.AppContainer, {}, provider); // appContainer -> provider -> router -> routes


  return appContainer;
}
/**
 * Sets the navObj - the object to pass between pages.
 * @param {object} navObj the navigation object
 */


function _setNavObj(appName, navObj) {
  _configureStore.configUtils.dispatch({
    type: 'UPDATE_' + appName,
    attrPath: ['navObj'],
    value: navObj,
    properties: {
      erase: navObj === undefined
    }
  });
}
/**
 * A method to help navigation between routes, the navObj is any payload
 * that needs to be transfered from one page to another.
 *
 * The navigation object is stored in the state
 * as the component is about to be mounted, we pass the navObj as a prop
 * to the component and post mounting, remove this object from the state.
 *
 * @param  {string} path   destination route url
 * @param  {object} navObj payload to pass between pages
 */


function navigateTo(path) {
  var navObj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!/^test/.test(process.env.NODE_ENV)) {
    // disable navigating in tests
    _setNavObj(appName, navObj);

    browserHistory.push(path);
  }
}
/**
 * Makes a route link to a specified path
 * @param  {object} linkProps { toPath, label } - url to route to and the label of the link
 * @return {element}          react-router Link element
 */


var RouteLink =
/*#__PURE__*/
function (_React$Component) {
  _inherits(RouteLink, _React$Component);

  function RouteLink() {
    _classCallCheck(this, RouteLink);

    return _possibleConstructorReturn(this, (RouteLink.__proto__ || Object.getPrototypeOf(RouteLink)).apply(this, arguments));
  }

  _createClass(RouteLink, [{
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(nextProps, nextState) {
      var result = (0, _phnxUtils.phnxShouldUpdate)(this.props, nextProps);
      result = result || (0, _phnxUtils.phnxShouldUpdate)(this.state, nextState);
      return result;
    }
  }, {
    key: "render",
    value: function render() {
      var _props$__passedProps = this.props.__passedProps,
          toPath = _props$__passedProps.toPath,
          otherProps = _objectWithoutProperties(_props$__passedProps, ["toPath"]);

      var children = this.props.children;

      if (!toPath || !children) {
        otherProps.style = {
          color: 'red'
        };
        delete otherProps.className;
      }

      toPath = toPath || '/bad-route-link-path';
      children = children || 'No children defined for this link tag';
      return _react.default.createElement(_reactRouterDom.Link, _extends({
        to: toPath
      }, otherProps), children);
    }
  }]);

  return RouteLink;
}(_react.default.Component);
/**
 * Initializes the redux store
 * @return {object} store object
 */


exports.RouteLink = RouteLink;

function initializeStore() {
  var store = (0, _configureStore.default)();
  return store;
}
/**
 * Initializes the app
 * @param  {string} pageName     name of the app
 * @param  {object} store        app store
 * @param  {object} initialState initial state of the app
 * @param  {array}  routesConfig an object describing the route configuration
 * @param   {array} dataConnections List of dataConnections defined in the app
 * @return {element}             Root element of the application
 */


function initializeApp(pageName, store, initialState, routesConfig, dataConnections) {
  var _Object$assign;

  var routes = routesConfig.routes,
      basepath = routesConfig.basepath;
  appName = pageName; // make the reducer in state for app

  (0, _dataManager.default)(appName, Object.assign({}, initialState, (_Object$assign = {}, _defineProperty(_Object$assign, ROUTES_CONFIG, routes), _defineProperty(_Object$assign, NAV_OBJ, {}), _defineProperty(_Object$assign, "dataConnections", dataConnections), _Object$assign))); // the output from here is to be consumed @index.js

  return _routeApp(appName, basepath, store, routes);
}