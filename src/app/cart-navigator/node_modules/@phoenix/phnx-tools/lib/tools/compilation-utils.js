"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transpile = transpile;
exports.removeDir = removeDir;

var _path = _interopRequireDefault(require("path"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var babel = _interopRequireWildcard(require("@babel/core"));

var _del = _interopRequireDefault(require("del"));

var _logger = _interopRequireDefault(require("@phoenix/phnx-internal-utils/lib/logger"));

var _babelConfig = _interopRequireDefault(require("../babelConfig"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

var env = _babelConfig.default.env,
    otherImpBabelConf = _objectWithoutProperties(_babelConfig.default, ["env"]);
/**
 * Recursively tranpiles code found in the entry path
 * @param  {string} entry   entry path for tranpilation
 * @param  {string} output  output path where the results are placed
 * @return {null}
 */


function doTranspile(entry, output) {
  var entries = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

  if (_fsExtra.default.lstatSync(entry).isDirectory()) {
    _fsExtra.default.readdirSync(entry).forEach(function (file) {
      doTranspile(_path.default.join(entry, file), _path.default.join(output, file), entries);
    });
  } else {
    var code; // transform file here

    if (/^.*\.js$/.test(entry)) {
      // transpile only *.js files
      code = babel.transformFileSync(entry, otherImpBabelConf).code;
    } else {
      code = _fsExtra.default.readFileSync(entry, 'utf8');
    }

    _fsExtra.default.outputFileSync(output, code);

    entries.push(entry);
  }
}
/**
 * Transpiles the files into the output path
 * @param  {string} entry   entry path for tranpilation
 * @param  {string} output  output path where the results are placed
 * @return {number}         0 - success; 1 - failure
 */


function transpile(entry, output) {
  try {
    var entries = [];
    doTranspile(entry, output, entries);

    _logger.default.info("Transpiled", entries);

    return 0;
  } catch (e) {
    _logger.default.error('Error while transpiling', {
      Stack: e.stack || e
    });
  }

  return 1;
}
/**
 * Removes the specified dir
 * @param  {string|array} dir full path to the dir that needs to be removed
 * @return {number}       0 - success; 1 - failure
 */


function removeDir(dir) {
  try {
    _logger.default.info("Deleting ".concat(dir), Array.isArray(dir) ? dir : [dir]);

    _del.default.sync(dir);

    return 0;
  } catch (e) {
    _logger.default.error("Unable to remove the dir: ".concat(dir), {
      Stack: e.stack || e
    });
  }

  return 1;
}