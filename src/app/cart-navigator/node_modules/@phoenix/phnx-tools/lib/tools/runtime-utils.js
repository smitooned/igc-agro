"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getOptions = getOptions;
exports.startServer = startServer;
exports.getEntry = getEntry;

var _path = _interopRequireDefault(require("path"));

var _https = _interopRequireDefault(require("https"));

var _express = _interopRequireDefault(require("express"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _dotenv = _interopRequireDefault(require("dotenv"));

var _immutable = require("@phoenix/phnx-internal-utils/lib/immutable");

var _logger = _interopRequireDefault(require("@phoenix/phnx-internal-utils/lib/logger"));

var _lib = require("@phoenix/phnx-internal-utils/lib");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// ----------- Getting config for the project ----------------
var configDefaults = {
  name: undefined,
  port: 3000,
  server: {
    entry: null,
    dependencies: {}
  },
  httpsConfig: undefined,
  basepath: '/phnx-app/',
  alias: {},
  outputPath: 'dist',
  chunkEntries: {},
  globals: {},
  runtimeConfig: {},
  webpackPlugins: [],
  webpackLoaders: [],
  env: 'development'
};
var defaultConfigKeys = Object.keys(configDefaults);
/**
 * Used for parsing command line arguments
 * @param  {array} args array of command line arguments
 * @return {object}     an object representing the arguments
 */

function getArguments(args) {
  var toReturn = {};
  args.splice(2).forEach(function (arg) {
    var match = arg.match(/^-([a-zA-Z\.-_]+)=([^\s]+)/);

    if (match) {
      var newArg = match[1].split('.').filter(Boolean).reduceRight(function (acc, curr) {
        return _defineProperty({}, curr, acc);
      }, match[2]);
      toReturn = (0, _immutable.mergeDeep)(toReturn, newArg);
    }
  });
  return toReturn;
}
/**
 * Parses the command line arguments & sets env vars
 * @param  {array} args command line arguments
 * @return {object}     options object
 */


function getOptions(args) {
  //Dotenv processing
  if (process.env.ENV_FILE) {
    _dotenv.default.config({
      path: _path.default.join(process.cwd(), process.env.ENV_FILE)
    });
  } else {
    var envFile = _path.default.join(process.cwd(), '.env');

    if (_fsExtra.default.existsSync(envFile)) {
      _dotenv.default.config({
        path: envFile
      });
    }
  }

  var options = getArguments(args);
  var configOpts = {};

  if (options.config != undefined) {
    var configJS = _path.default.join(process.cwd(), options.config);

    try {
      var config = require(configJS) || {}; // the command line arguments take precedence
      // Object.assign(config, options)

      configOpts = (0, _immutable.mergeDeep)(config, options);
    } catch (e) {
      _logger.default.error('config.js not in the correct format, will use defaults', {
        Stack: e.stack || e
      });
    }
  } else {
    _logger.default.warn("config.js not found in project root, will use defaults");
  } //ensuring nothing extra gets carried over beyond this point


  Object.keys(configOpts).forEach(function (key) {
    if (!defaultConfigKeys.includes(key)) {
      delete configOpts[key];
    }
  });
  return (0, _immutable.mergeDeep)(configDefaults, configOpts);
} // --------------- Start server -----------------------

/**
 * Retrieve the https configurations from the options object
 * @param  {object} options config.options
 * @return {object}         the https configuration object needed for https.createServer
 */


function getHTTPSConfig(options) {
  var ret = {};

  if (options) {
    try {
      Object.keys(options).map(function (option) {
        if (/^file:/.test(options[option])) {
          var filePath = options[option].replace(/^file:/, '');
          ret[option] = _fsExtra.default.readFileSync(_path.default.join(process.cwd(), filePath));
        } else {
          ret[option] = options[option];
        }
      });
    } catch (e) {
      ret = null;

      _logger.default.error('Something went wrong with getting the HTTPS options, will fallback to http', {
        Stack: e.stack || e
      });
    }
  } else {
    ret = null;
  }

  return ret;
}
/**
 * Used to register middlewares to the express app
 * @param  {object} options   config.options
 */


function registerMiddlewares(app, options) {
  /* registering middlewares */
  if ((0, _lib.checkType)(options.middlewares, 'array')) {
    // for dev middlewares/other middlewares
    options.middlewares.forEach(function (middleware) {
      if (!(0, _lib.checkType)(middleware, 'array')) {
        middleware = [middleware];
      } // for scenarios like - app.use('/static', express.static(__dirname));


      app.use.apply(app, middleware);
    });
  }

  _logger.default.info('Middlewares have been registered!');
}

function registerUserServices(app, appServer, options) {
  /* registering services */
  if (options.server && typeof options.server.entry == 'function') {
    try {
      // load the custom server apis
      options.server.entry(app, appServer, options);

      _logger.default.info('Custom APIs have been registered!');
    } catch (e) {
      _logger.default.error('Something went wrong while registering the custom APIs', {
        Stack: e.stack || e
      });
    }
  } else {
    _logger.default.warn('Custom APIs have not been specified in the correct format in config.js', options);
  }
}
/**
 * Brings up the application server
 * @param  {object} options config.options
 * @return {null}
 */


function startServer(options) {
  // registering middlewares
  var app = (0, _express.default)();
  var port = options.port;
  var appServer;
  var serverOpts = getHTTPSConfig(options.httpsConfig); //consider ignoring httpsConfig only if env is defined

  var shouldStartHttps = serverOpts && (serverOpts.env !== undefined ? serverOpts.env === options.env : true);

  if (shouldStartHttps) {
    appServer = _https.default.createServer(serverOpts, app); // this is a https server

    appServer.listen(port, onStart);
  } else {
    // this is a http server
    appServer = app.listen(port, onStart);
  } // app, server, port are in present in the closure


  function onStart(err) {
    if (err) {
      _logger.default.error('Something went wrong with starting the app', {
        error: err
      });

      return 0;
    }

    var protocol = shouldStartHttps ? 'https://' : 'http://'; // register user services first so stuff like cors can be taken care of
    // by the user services

    registerUserServices(app, appServer, Object.assign({}, options)); // register middlewares - stuff like express.static, history-fallback-api

    registerMiddlewares(app, options);
    var openUrl = "".concat(protocol, "localhost:").concat(port).concat(options.basepath);

    _logger.default.info("Application hosted on: ".concat(openUrl));
  }
}
/**
 * Requires a file specified by the entry parameter
 * @param  {string}   entry path to a file to require
 * @return {function}       function exported by the file
 */


function getEntry(entry) {
  try {
    var fn = require(entry);

    if ((0, _lib.checkType)(fn, 'function')) {
      return fn;
    } else {
      _logger.default.warn('Expected the server entry to point to a module that exports a function', {
        entry: entry
      });
    }
  } catch (e) {
    _logger.default.error('Error in the custom APIs', {
      Stack: e.stack || e
    });
  }

  return function () {
    /*do nothing*/
  };
}