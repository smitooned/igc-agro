"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.prePhnxBabelConf = void 0;

var _path = _interopRequireDefault(require("path"));

var _webpack = _interopRequireDefault(require("webpack"));

var _htmlWebpackPlugin = _interopRequireDefault(require("html-webpack-plugin"));

var _InjectRuntimeConfig = _interopRequireDefault(require("./InjectRuntimeConfig"));

var _miniCssExtractPlugin = _interopRequireDefault(require("mini-css-extract-plugin"));

var _uglifyjsWebpackPlugin = _interopRequireDefault(require("uglifyjs-webpack-plugin"));

var _phnxInternalUtils = require("@phoenix/phnx-internal-utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var devEnv = 'development';
var prodEnv = 'production';
var appHtml = 'public/index.html';
var projPath = process.cwd();
var prePhnxBabelConf = {
  babelrc: false,
  plugins: ['@phoenix/phnx-loader/lib/helpers/phnxAST.js']
};
exports.prePhnxBabelConf = prePhnxBabelConf;

function makePathsAbsolute(objOrArray) {
  var toReturn;

  if ((0, _phnxInternalUtils.checkType)(objOrArray, 'object')) {
    toReturn = {};
    var item;

    for (item in objOrArray) {
      if ((0, _phnxInternalUtils.checkType)(objOrArray[item], 'string')) {
        toReturn[item] = _path.default.join(projPath, objOrArray[item]);
      } else if ((0, _phnxInternalUtils.checkType)(objOrArray[item], 'array') || (0, _phnxInternalUtils.checkType)(objOrArray[item], 'object')) {
        toReturn[item] = makePathsAbsolute(objOrArray[item]);
      } else {
        toReturn[item] = objOrArray[item];
      }
    }
  } else if ((0, _phnxInternalUtils.checkType)(objOrArray, 'array')) {
    toReturn = objOrArray.map(function (item) {
      if ((0, _phnxInternalUtils.checkType)(item, 'string')) {
        return _path.default.join(projPath, item);
      }

      return item;
    });
  }

  return toReturn;
}

function getAlias(options) {
  var alias = {
    SRC: 'src'
  };

  if ((0, _phnxInternalUtils.checkType)(options.alias, 'object')) {
    alias = _objectSpread({}, alias, options.alias);
  }

  return makePathsAbsolute(alias);
}

function getEntry(mode, options) {
  var hotMidware = 'webpack-hot-middleware/client?reload=true';
  var entry = {
    app: ['src/index.phnxapp']
  };

  if ((0, _phnxInternalUtils.checkType)(options.chunkEntries, 'object')) {
    entry = _objectSpread({}, options.chunkEntries, entry);
  }

  entry = makePathsAbsolute(entry);

  if (mode === devEnv) {
    for (var item in entry) {
      entry[item].unshift(hotMidware);
      entry[item].unshift('react-hot-loader/patch');
    }
  }

  return entry;
}

function getPlugins(mode, options) {
  var globals = {
    'process.env.NODE_ENV': mode,
    __DEV__: mode === devEnv
  };

  if ((0, _phnxInternalUtils.checkType)(options.globals, 'object')) {
    globals = _objectSpread({}, globals, options.globals);
  }

  var item;

  for (item in globals) {
    if ((0, _phnxInternalUtils.checkType)(globals[item], 'string')) {
      globals[item] = JSON.stringify(globals[item]);
    }
  }

  var plugins = [new _webpack.default.DefinePlugin(globals), new _htmlWebpackPlugin.default({
    template: _path.default.join(projPath, appHtml),
    inject: true // this controls injecting all the assets into the html

  }), new _InjectRuntimeConfig.default({
    runtimeConfig: options.runtimeConfig
  })];

  if (mode === devEnv) {
    plugins.push(new _webpack.default.HotModuleReplacementPlugin());
  } else {
    plugins.push(new _miniCssExtractPlugin.default({
      filename: '[name].[chunkhash:8].css'
    }));
  } // user plugins


  if ((0, _phnxInternalUtils.checkType)(options.webpackPlugins, 'array')) {
    var userPlugins = options.webpackPlugins.map(function (plugin) {
      var pluginPath = _path.default.join(projPath, plugin.location);

      var plug = require(pluginPath);

      var pluginOptions = {};

      if ((0, _phnxInternalUtils.checkType)(plugin.options, 'object')) {
        pluginOptions = plugin.options;
      }

      return new plug(pluginOptions);
    });
    plugins = _toConsumableArray(userPlugins).concat(_toConsumableArray(plugins));
  }

  return plugins;
}

function getRules(mode, options) {
  var eslintLoader = {
    loader: 'eslint-loader',
    options: {
      configFile: _path.default.join(__dirname, './eslintConfig.js')
    }
  };
  var babelLoader = {
    loader: 'babel-loader',
    options: require(_path.default.join(__dirname, './babelConfig.js'))
  };
  var postCssLoader = {
    loader: 'postcss-loader',
    options: {
      ident: 'postcss',
      plugins: function plugins() {
        return [require('postcss-flexbugs-fixes'), require('autoprefixer')({
          browsers: ['Chrome 59', 'Firefox 53']
        })];
      }
    }
  };
  var cssLoaderChain;

  if (mode === devEnv) {
    cssLoaderChain = ['style-loader', 'css-loader', postCssLoader];
  } else {
    cssLoaderChain = [_miniCssExtractPlugin.default.loader, {
      loader: 'css-loader',
      options: {
        minimize: true
      }
    }, postCssLoader];
  }

  var allLoaders = [{
    test: [/\.bmp$/, /\.gif$/, /\.jpe?g$/, /\.png$/],
    loader: 'url-loader',
    options: {
      limit: 10000,
      name: 'assets/[name].[hash:8].[ext]'
    }
  }, {
    test: /\.(js|jsx)$/,
    include: [_path.default.join(projPath, 'src'), _path.default.join(projPath, 'test')],
    use: [babelLoader]
  }, {
    test: /\.phnx$/,
    use: [babelLoader, eslintLoader, '@phoenix/phnx-loader', {
      loader: 'babel-loader',
      options: prePhnxBabelConf
    }]
  }, {
    test: /\.phnxapp$/,
    use: [babelLoader, eslintLoader, '@phoenix/phnx-loader/lib/phnxAppLoader.js']
  }, {
    test: /\.phnxdef$/,
    use: [babelLoader, eslintLoader, '@phoenix/phnx-loader/lib/phnxDefLoader.js']
  }, {
    test: /\.css$/,
    use: cssLoaderChain
  }, {
    exclude: [/\.js$/, /\.html$/, /\.json$/, /\.ejs$/],
    loader: 'file-loader',
    options: {
      name: 'assets/[name].[hash:8].[ext]'
    }
  }];

  if ((0, _phnxInternalUtils.checkType)(options.webpackLoaders, 'array')) {
    allLoaders = _toConsumableArray(options.webpackLoaders).concat(_toConsumableArray(allLoaders));
  }

  var loaders = [{
    test: /\.(js|jsx)$/,
    enforce: 'pre',
    use: [eslintLoader],
    include: [_path.default.join(projPath, 'src'), _path.default.join(projPath, 'test')]
  }, {
    oneOf: allLoaders
  }];
  return loaders;
}

function getOutputPath(mode, options) {
  var outputPath = '/';

  if (mode === prodEnv) {
    outputPath = _path.default.join(projPath, options.outputPath);
  }

  return outputPath;
}

function getPublicPath(mode, options) {
  var publicPath = '/';

  if (mode === prodEnv) {
    publicPath = (options.basepath || '').replace(/^\/?(.*?)\/?$/, function (match, value) {
      return value === '' ? value : "/".concat(value, "/");
    });
  }

  return publicPath;
}

function _default(mode, options) {
  var publicPath = getPublicPath(mode, options);
  options.publicPath = publicPath;
  return {
    mode: mode,
    devtool: mode === devEnv ? 'source-map' : false,
    resolve: {
      extensions: ['.js', '.jsx', '.phnx', '.phnxapp'],
      alias: getAlias(options)
    },
    entry: getEntry(mode, options),
    plugins: getPlugins(mode, options),
    module: {
      rules: getRules(mode, options)
    },
    output: {
      path: getOutputPath(mode, options),
      // Note: Physical files are only output by the production build task `npm run build`.
      publicPath: publicPath,
      // this controls how your index.html makes requests for bundle.js, styles, etc
      filename: mode === devEnv ? '[name].js' : '[name].[chunkhash:8].js'
    }
  };
}