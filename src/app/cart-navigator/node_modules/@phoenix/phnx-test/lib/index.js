"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shallow = shallow;
exports.mount = mount;
exports.generateSnapshot = generateSnapshot;
exports.methodSpy = methodSpy;
exports.methodStub = methodStub;
exports.getModel = getModel;
Object.defineProperty(exports, "spy", {
  enumerable: true,
  get: function get() {
    return _sinon.spy;
  }
});
Object.defineProperty(exports, "stub", {
  enumerable: true,
  get: function get() {
    return _sinon.stub;
  }
});
Object.defineProperty(exports, "initMock", {
  enumerable: true,
  get: function get() {
    return _mockCallActions.initMock;
  }
});
Object.defineProperty(exports, "resetMock", {
  enumerable: true,
  get: function get() {
    return _mockCallActions.resetMock;
  }
});

var _react = _interopRequireDefault(require("react"));

var _enzyme = require("enzyme");

var _enzymeToJson = _interopRequireDefault(require("enzyme-to-json"));

var _sinon = require("sinon");

var _validators = require("@phoenix/phnx-internal-utils/lib/validators");

var _phnxInternalUtils = require("@phoenix/phnx-internal-utils");

var _configureStore = require("@phoenix/phnx-utils/lib/store/configureStore");

var _dataManager = _interopRequireDefault(require("@phoenix/phnx-utils/lib/data-manager"));

var _phnxUtils = require("@phoenix/phnx-utils");

var _mockCallActions = require("./mock-call-actions");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var expectedAllArgs = {
  props: {
    isMan: false,
    type: 'object'
  },
  model: {
    isMan: false,
    type: 'object'
  },
  appModel: {
    isMan: false,
    type: 'object'
  },
  otherModel: {
    isMan: false,
    type: 'object'
  },
  privateVarDefaults: {
    isMan: false,
    type: 'object'
  },
  eventHandlers: {
    isMan: false,
    type: 'object',
    childObjStructure: {
      '__CHECK-ALL__': {
        type: 'function'
      }
    }
  }
};
var APPNAME = '__TestingApp';

function extractFromStateAndMerge(name, newVal, makeReducer) {
  var old = _configureStore.configUtils.getState()[name] || {};

  var mergedVal = _objectSpread({}, old, newVal);

  if (makeReducer) {
    (0, _dataManager.default)(name, mergedVal);
  }

  return mergedVal;
}
/**
 * Makes arguments that can be passed into a React.createElement
 * @param  {boolean}  makeReducer                       boolean which controls if reducer is made for component
 * @return {array}                                      [ClassDefn, props, children]
 */


function makeArgsForCreateElement(ComponentDefn, allArgs) {
  var makeReducer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  (0, _validators.validateAll)('Render component', allArgs, expectedAllArgs, 'Render arguments');
  var props = allArgs.props || {};
  var model = allArgs.model || {};
  var appModel = allArgs.appModel || {};
  var otherModel = allArgs.otherModel || {};
  var privateVarDefaults = allArgs.privateVarDefaults || {};
  var eventHandlers = allArgs.eventHandlers || {}; //Error checks

  if (!ComponentDefn) {
    throw new Error('Component Definition is undefined! Make sure you are imports are correct.');
  }

  if (ComponentDefn.name.toLowerCase() === 'phnxtestdummy') {
    throw new Error("Wrong component passed, need to import 'Test<ComponentName>' from the phnx file");
  } //Variable declarations


  var componentName = ComponentDefn.phnxCompName;

  var splat = props.splat,
      children = props.children,
      navObj = props.navObj,
      key = props.key,
      match = props.match,
      passedProps = _objectWithoutProperties(props, ["splat", "children", "navObj", "key", "match"]);

  var componentProps = _objectSpread({
    key: key,
    splat: splat,
    match: match,
    navObj: navObj,
    __appName: APPNAME,
    __passedProps: passedProps,
    __passedDefaults: privateVarDefaults
  }, eventHandlers);
  /* ----- Create Store models ------- */
  //Create component model


  var newCompState = extractFromStateAndMerge(componentName, model, makeReducer);
  componentProps = _objectSpread({}, componentProps, newCompState); //Create App model

  var newAppState = extractFromStateAndMerge(APPNAME, appModel, makeReducer);
  componentProps.__appModel = newAppState; // Create other models - Is this needed?

  Object.keys(otherModel).forEach(function (modelName) {
    extractFromStateAndMerge(modelName, otherModel[modelName], makeReducer);
  });
  /* ----- End of Create Store models ------- */

  return [ComponentDefn, componentProps, children];
}
/**
 * This function will generate a wrapper for this component without rendering its children.
 * Recommended to use this in most of the scenarios.
 * @return {object}  ShallowWrapper. http://airbnb.io/enzyme/docs/api/shallow.html
 */


function shallow(ComponentDefn) {
  var allArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var args = makeArgsForCreateElement(ComponentDefn, allArgs, true);

  var element = _react.default.createElement.apply(null, args);

  var shallowWrapper = (0, _enzyme.shallow)(element);
  return attachMoreAPI(shallowWrapper);
}
/**
 * This function will generate a wrapper with all its children and all its lifecycles.
 * @return {object}  wrapper. http://airbnb.io/enzyme/docs/api/mount.html
 */


function mount(ComponentDefn) {
  var allArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var args = makeArgsForCreateElement(ComponentDefn, allArgs, true);

  var element = _react.default.createElement.apply(null, args);

  var wrapper = (0, _enzyme.mount)(element);
  return attachMoreAPI(wrapper);
}

function generateSnapshot(wrapper) {
  return (0, _enzymeToJson.default)(wrapper);
}

function simulateCustom(elId, event, eventObj, payload, properties) {
  var elObj = this.__finalEventMap[elId];

  if (elObj) {
    if (elObj[event]) {
      elObj[event](eventObj, payload, properties);
    } else {
      throw new Error("There is no listener associated to event ".concat(event, " on element with ID ").concat(elId));
    }
  } else {
    throw new Error("The element with id ".concat(elId, " doesn't have any events associated with it"));
  }
}

function getMethod(fnName) {
  var isWorkflow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var func = isWorkflow ? this['wf_' + fnName] : this[fnName];

  if (!func) {
    throw new Error("The function/workflow doesn't exist");
  }

  return func;
}

function updateVariable(what, val) {
  var isAppModel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  if (!(0, _phnxInternalUtils.checkType)(isAppModel, 'boolean')) {
    throw new Error('The isAppModel is expected to be a boolean');
  }

  var compThis = this.instance();
  var typeDetails = isAppModel ? {
    scope: 'appModel'
  } : compThis.varTypeMap[what];

  if (typeDetails === undefined) {
    throw new Error("The variable ".concat(what, " is not defined in variables"));
  }

  if (typeDetails.scope === 'protected') {
    throw new Error("Updating protected variable is not supported yet");
  }

  var toUpdate;

  switch (typeDetails.scope) {
    case 'private':
      compThis.__localVars[what] = val;
      compThis.forceUpdate();
      break;

    case 'public':
      toUpdate = {
        __passedProps: _defineProperty({}, what, val)
      };
      this.setProps(toUpdate);
      break;

    case 'model':
      toUpdate = _defineProperty({}, what, val);
      this.setProps(toUpdate);
      break;

    case 'appModel':
      toUpdate = {
        __appModel: _defineProperty({}, what, val)
      };
      this.setProps(toUpdate);
      break;

    default: //It should never come here

  }
}

function attachMoreAPI(wrapper) {
  wrapper.getVariable = _phnxUtils.getVariable.bind(wrapper.instance());
  wrapper.simulateCustom = simulateCustom.bind(wrapper.instance());
  wrapper.getMethod = getMethod.bind(wrapper.instance());
  wrapper.updateVariable = updateVariable.bind(wrapper);
  return wrapper;
}
/**
 * Spy a function in phoenix component
 * @param  {object}  obj         A wrapper generated using enzyme API or Test Export from `.phnx` file
 * @param  {string}  fnName      Name of the function to be spied
 * @param  {Boolean} isWorkflow  Boolean to control whether its a workflow or not.
 * @return {object}              The spy that was created as a result of this
 */


function methodSpy(obj, fnName) {
  var isWorkflow = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var source;

  if (obj.constructor.name === 'ShallowWrapper' || obj.constructor.name === 'ReactWrapper') {
    throw new Error('Cannot spy the functions/workflows after rendering, do it on the Class definition');
  } else {
    source = obj.prototype;
    fnName = isWorkflow ? 'wf_' + fnName : fnName;
  }

  return (0, _sinon.spy)(source, fnName);
}
/**
 * Stub out function in phoenix component
 * @param  {object}  obj         A wrapper generated using enzyme API or Test Export from `.phnx` file
 * @param  {string}  fnName      Name of the function to be spied
 * @param  {Boolean} isWorkflow  Boolean to control whether its a workflow or not.
 * @return {object}              The stub that was created as a result of this
 */


function methodStub(obj, fnName) {
  var isWorkflow = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var source;

  if (obj.constructor.name === 'ShallowWrapper' || obj.constructor.name === 'ReactWrapper') {
    throw new Error('Cannot stub the functions/workflows after rendering, do it on the Class definition');
  } else {
    source = obj.prototype;
    fnName = isWorkflow ? 'wf_' + fnName : fnName;
  }

  return (0, _sinon.stub)(source, fnName);
}

function getModel() {
  var isAppModel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  var otherCompName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  var state = _configureStore.configUtils.getState();

  if (isAppModel) {
    return state[APPNAME];
  } else {
    if (!(0, _phnxInternalUtils.checkType)(otherCompName, 'string')) {
      throw new Error('The name of the other component needs to be a string');
    }

    return state[otherCompName] || {};
  }
}
/**
 * APIs to export
 */