"use strict";

var _common = require("./helpers/common");

var _expectStructure = _interopRequireDefault(require("./helpers/expect-structure"));

var _prettier = _interopRequireDefault(require("prettier"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var importsMap;
/**
 * This function returns the initial barebone structure of the root app
 * @return {string}  javascript corresponding to index.js
 */

var makeBarebones = function makeBarebones() {
  return "\nimport * as secret_utils from '@phoenix/phnx-utils';\nimport { renderDOM } from '@phoenix/phnx-loader/lib/helpers/base-component';\nimport initializeApp from '@phoenix/phnx-utils/lib/dynamic-routing/index';\nimport store from '@phoenix/phnx-utils/lib/dynamic-routing/store';\nimport Loadable from '@phoenix/phnx-loader/lib/helpers/loadable';\n\n/* each component import might bring with it, a reducer addition to the state */\n#__##IMP_START\n\nconst dataConnections = {#__##ACT_START};\nconst routesConfig = #__##ROUTE_IMP;\n\nconst AppRoutes = initializeApp(appName, store, appModel, routesConfig, dataConnections);\nrenderDOM(AppRoutes, document.getElementById('app'));\n\nif(module.hot) {\n    // make the updates self-accepting\n    module.hot.accept();\n}\n";
};
/**
 * This function adds the required require statements for css imports
 * @param  {string} jsx_source  current source
 * @param  {array } cssImports  Array of css file paths
 * @return {string}             source after inserting css imports
 */


function addCSSImports(jsx_source, cssImports) {
  var ret_str = jsx_source;
  cssImports = cssImports.reverse();
  cssImports.forEach(function (item) {
    var statement = "require('".concat(item, "'); \n");
    ret_str = (0, _common.doReplace)(ret_str, '#__##IMP_START', statement);
  });
  return ret_str;
}
/**
 * Function to add all the moduleImports statements to the phnxapp
 * @param  {string} jsx_source    Current source string
 * @param  {array } moduleImports      The array of import objects defined in phnx class
 * @return {string}              The source string after moduleImports addition
 */


function addImports(jsx_source, moduleImports) {
  var ret_str = jsx_source;
  moduleImports.reverse().forEach(function (item) {
    var statement = '';
    var take = item.take;

    if (typeof take === 'string') {
      statement = "import { ".concat(take, " } from '").concat(item.from, "'; ");
    } else if (_typeof(take) === 'object' && !(take instanceof Array)) {
      if (take.what === '*') {
        statement = "import * as ".concat(take.as, " from '").concat(item.from, "'; ");
      } else if (take.what === 'default') {
        statement = "import ".concat(take.as, " from '").concat(item.from, "'; ");
      } else {
        statement = "import { ".concat(take.what, " as ").concat(take.as, " } from '").concat(item.from, "'; ");
      }
    } else if (take instanceof Array && take.length > 0) {
      statement = 'import {';
      take.forEach(function (obj) {
        if (typeof obj === 'string') {
          statement += "".concat(obj, ", ");
        } else if (_typeof(obj) === 'object' && !(obj instanceof Array)) {
          if (obj.what === '*' || obj.what === 'default') {
            throw new TypeError("The imports cannot have ".concat(obj.what, " inside an array"));
          }

          statement += "".concat(obj.what, " as ").concat(obj.as, ", ");
        } else {
          throw new TypeError("The array of imports has to have either objects or string");
        }
      });
      statement = statement.replace(/,?\s*$/, '}');
      statement += " from '".concat(item.from, "'; ");
    }

    ret_str = (0, _common.doReplace)(ret_str, '#__##IMP_START', statement);
  });
  return ret_str;
}
/**
 * This function is to do the parsing on the dataconnection objects before passing it along
 * @param  {array } dataConnections The array of dataconnection objects
 * @return {array }                 Parsed data connection objects
 */


function parseDataConnections(dataConnections, name) {
  return dataConnections.map(function (obj) {
    //This attribute's existence is guranteed by the expect structure
    var tmpReqParams = JSON.stringify(obj.requestParams);
    var sourceObjNeeded;
    tmpReqParams = tmpReqParams.replace(/"[^"]*(__var__|__appModel__|__fn__|__prop__|__elId__|__imports__)[^"]*"/g, function (matched) {
      var res = resolvePrefixes(matched.substr(1, matched.length - 2), name);
      sourceObjNeeded = res.hasChanged;
      return res.result;
    });
    obj.requestParams = tmpReqParams;
    obj.__sourceObjNeeded = !!sourceObjNeeded;
    return obj;
  });
}
/**
 * Adds the dataconnections to the source string
 * @param {string} jsx_source source string
 * @param {object} dconn      dataconnection object
 * @param {strin} name        name of the app
 */


function addDataConns(jsx_source, dconns, name) {
  Object.keys(dconns).forEach(function (item) {
    //Each data is already in strings, no need to convert
    var evalString = dconns[item];
    var statement;

    if (_typeof(evalString) == 'object') {
      statement = item + ':{' + Object.keys(evalString).map(function (key) {
        return "".concat(key, " : ").concat(resolvePrefixes(evalString[key], name).result);
      }) + '},\n';
    } else {
      statement = item + ': ' + evalString + ',\n';
    }

    jsx_source = (0, _common.doReplace)(jsx_source, '#__##ACT_START', statement);
  });
  return jsx_source;
}
/**
 * Returns an object mapping connection names to the string representation
 * of the connection apis
 * @param  {string} pageName          name of the page
 * @param  {Array}  dataConnectionArr an array of dataConnection objects
 * @return {object}                   an object mapping the connection names to the string
 *                                    representation of the connection apis
 */


function makeDataConnections(pageName, dataConnectionArr) {
  var dConns = {};
  dataConnectionArr.forEach(function (dataConnectionObj) {
    dConns[dataConnectionObj.id] = makeDataConnAPIs(pageName, dataConnectionObj);
  });
  return dConns;
}
/**
 * Returns string representation of an object which contains
 * the apis for communicating with the data connection.
 * @param  {string} pageName           name of the page
 * @param  {object} dataConnectionObj  the connection object
 * @return {string}                    string representation of the connection apis
 */


function makeDataConnAPIs(pageName, dataConnectionObj) {
  var asyncActions;
  var connectionName = dataConnectionObj.id;
  var connectionType = dataConnectionObj.type;
  var requestParams = dataConnectionObj.requestParams;
  var sourceObjNeeded = dataConnectionObj.__sourceObjNeeded;
  var apisToGet = [];

  if (/REST/i.test(connectionType)) {
    apisToGet = ['request'];
  } else if (/SOCKET/i.test(connectionType)) {
    apisToGet = ['connect', 'disconnect', 'send'];
  } // putting pieces together to make js


  asyncActions = new MakeConnectionCode().getApis({
    name: connectionName,
    connectionType: connectionType,
    requestParams: requestParams,
    pageName: pageName,
    sourceObjNeeded: sourceObjNeeded
  }, apisToGet); //This is dummy, will get replaced by socket initiation

  asyncActions.dataConnector = 'null';
  return asyncActions;
}
/**
 * A function used to make code for async actions for REST(request)
 * and SOCKET(connect, send, disconnect)
 * Use getApi to get all the apis.
 */


function MakeConnectionCode() {
  var _this = this;

  MakeConnectionCode.prototype.request = function (_ref) {
    var name = _ref.name,
        connectionType = _ref.connectionType,
        requestParams = _ref.requestParams,
        pageName = _ref.pageName,
        sourceObjNeeded = _ref.sourceObjNeeded;
    return "(callbacks, payload, properties".concat(sourceObjNeeded ? ', source' : '', ") => {\n        properties = properties || {};\n        const requestParams = ").concat(requestParams, ";\n        return secret_utils.doRequest(\"").concat(connectionType, "\", requestParams, callbacks, payload, properties);\n    }\n    ");
  };

  MakeConnectionCode.prototype.connect = function (_ref2) {
    var name = _ref2.name,
        connectionType = _ref2.connectionType,
        requestParams = _ref2.requestParams,
        pageName = _ref2.pageName,
        sourceObjNeeded = _ref2.sourceObjNeeded;
    return "(callbacks) => {\n        /* async action to connect and register event handles with the source */\n        const requestParams = ".concat(requestParams, ";\n        return secret_utils.doConnect(\"").concat(name, "\", \"").concat(connectionType, "\", requestParams, callbacks, \"").concat(pageName, "\");\n    }\n    ");
  };

  MakeConnectionCode.prototype.disconnect = function (_ref3) {
    var name = _ref3.name,
        connectionType = _ref3.connectionType,
        requestParams = _ref3.requestParams,
        pageName = _ref3.pageName,
        sourceObjNeeded = _ref3.sourceObjNeeded;
    return "() => {\n        /* sync action to disconnect from the source */\n        return secret_utils.doDisconnect(\"".concat(name, "\", \"").concat(pageName, "\");\n    }\n    ");
  };

  MakeConnectionCode.prototype.send = function (_ref4) {
    var name = _ref4.name,
        connectionType = _ref4.connectionType,
        requestParams = _ref4.requestParams,
        pageName = _ref4.pageName,
        sourceObjNeeded = _ref4.sourceObjNeeded;
    return "(callbacks, payload) => {\n        /* sync action to send a message */\n        return secret_utils.doSend(\"".concat(name, "\", \"").concat(pageName, "\", payload.event, payload.message);\n    }\n    ");
  };
  /**
   * This method is used to generate all the neccessary apis
   *
   * @param  {string} options.name             name of the connection object
   * @param  {string} options.connectionType   connection type
   * @param  {string} options.requestParams    connection parameters
   * @param  {string} options.pageName         name of the page
   * @param  {array}  apisToGet                array of names of the apis to construct
   * @return {object}                          an object mapping api name to it's string representation
   */


  MakeConnectionCode.prototype.getApis = function (_ref5, apisToGet) {
    var name = _ref5.name,
        connectionType = _ref5.connectionType,
        requestParams = _ref5.requestParams,
        pageName = _ref5.pageName,
        sourceObjNeeded = _ref5.sourceObjNeeded;
    var apis = {};
    apisToGet.forEach(function (apiName) {
      apis[apiName] = _this[apiName].call(null, {
        name: name,
        connectionType: connectionType,
        requestParams: requestParams,
        pageName: pageName,
        sourceObjNeeded: sourceObjNeeded
      });
    });
    return apis;
  };
}
/**
 * This function recursively adds import statements for each componet
 * @param  {string}  jsx_source  JSX source at current state
 * @param  {array}   routes      The current routes array
 * @param  {boolean} isLazy      Controls if whether the route is lazy loaded or not
 * @return {string}              source after inserting route component imports
 */


function doRoutes(jsx_source, routes) {
  var ret_str = jsx_source;
  routes.forEach(function (item) {
    if (!importsMap[item.componentPath]) {
      var statement;

      if (item.hasOwnProperty('lazyLoad') && item.lazyLoad === false) {
        statement = "const ".concat(item.name, " = require('").concat(item.componentPath, "').default;\n");
      } else {
        statement = "const ".concat(item.name, " = Loadable({loader: () => import( /* webpackChunkName: \"").concat(item.name, "\" */ '").concat(item.componentPath, "')});\n");
      }

      ret_str = (0, _common.doReplace)(ret_str, '#__##IMP_START', statement);
      importsMap[item.componentPath] = true;
    }

    if (item.routes && item.routes.length) {
      ret_str = doRoutes(ret_str, item.routes);
    }
  });
  return ret_str;
}
/**
 * This function parses through routes adding import statement and modifying the array
 * @param  {string} jsx_source   JSX source at current state
 * @param  {array}  routesConfig The routes configuration array
 * @param  {string} name         name of the app
 * @return {string}              source after inserting route info
 */


function parseRoutes(jsx_source, routesConfig, name) {
  importsMap = {};
  var ret_str = doRoutes(jsx_source, routesConfig.routes);
  var actualRoutesConfig = getRoutesConfig(routesConfig, name);
  ret_str = (0, _common.doReplace)(ret_str, '#__##ROUTE_IMP', actualRoutesConfig);
  return ret_str;
}
/**
 * This function return strings for routes array where the componentPath has
 * been replaced with reference to its definition
 * @param  {object} routesConfig the routes configuration object
 * @return {string}              Return the stringified version of routesConfig object
 */


function getRoutesConfig(routesConfig, name) {
  return resolvePrefixes("{\n        basepath: ".concat(/^__parse__/.test(routesConfig.basepath) ? routesConfig.basepath.replace(/^__parse__/, '') : "\"".concat(routesConfig.basepath, "\""), ",\n        routes: ").concat(function recurseRoutes(routes) {
    var ret_str = ' [ ';
    routes.forEach(function (item) {
      var name = item.name;
      var currRoutes = item.routes;
      var obj = Object.assign({}, item);
      var component = "component: ".concat(name); // name added below to denote that componentPath is just unquoted `name`
      // which means that its a reference to the imported component

      delete obj.name;
      delete obj.routes;
      delete obj.componentPath;
      var toAdd = (0, _common.funcStringify)(obj);
      var routeChildren = '';

      if (Array.isArray(currRoutes) && currRoutes.length) {
        routeChildren = ", routes: ".concat(recurseRoutes(currRoutes));
      }

      toAdd = toAdd.replace(/}\s*$/, ", name: \"".concat(name, "\", ").concat(component, " ").concat(routeChildren, "}, "));
      ret_str += toAdd;
    });
    ret_str = ret_str.replace(/,\s*$/, '');
    ret_str += ' ]';
    return ret_str;
  }(routesConfig.routes), "\n    }"), name).result;
}

function resolvePrefixes(evalString, name) {
  if (typeof evalString == 'string') {
    var ret_str = evalString,
        sourceUsed = false;
    ret_str = ret_str.replace(/__var__(?:([A-Za-z0-9_]+)|\[([A-Za-z0-9_\'\"]+)\])/g, function (got, s1, s2) {
      sourceUsed = true;

      if (s1 !== undefined) {
        return "secret_utils.getVariable.call(source, '".concat(s1, "')");
      }

      return "secret_utils.getVariable.call(source, ".concat(s2, ")");
    });
    ret_str = ret_str.replace(/__imports__/g, '');
    ret_str = ret_str.replace(/__appModel__/g, "secret_utils.getState()[\"".concat(name, "\"]."));
    ret_str = ret_str.replace(/__fn__/g, function () {
      sourceUsed = true;
      return 'source.';
    });
    return {
      result: ret_str,
      hasChanged: sourceUsed
    };
  } else return evalString;
}
/**
 * Webpack loader function
 */


function phnxAppLoader(source) {
  //Gets the module.exports from each file
  var appData = this.exec(source, this.resourcePath);
  (0, _expectStructure.default)(appData, 'phnxapp', this.resourcePath);
  var name = appData.name;
  name.charAt(0).toUpperCase();
  var appModel = appData.appModel || {};
  var cssImports = appData.cssImports || [];
  var routesConfig = appData.routesConfig;
  var dataConnections = appData.dataConnections || [];
  var moduleImports = appData.moduleImports || [];

  if (routesConfig.routes.length === 0) {
    throw new Error('Expected the routes array to contain at least one route object');
  }

  var jsx_source = makeBarebones();
  var statement = 'const appName = ' + JSON.stringify(name) + ' ;\n';
  jsx_source = (0, _common.doReplace)(jsx_source, '#__##IMP_START', statement);
  statement = 'const appModel = ' + JSON.stringify(appModel) + ' ;\n';
  jsx_source = (0, _common.doReplace)(jsx_source, '#__##IMP_START', statement);
  jsx_source = addCSSImports(jsx_source, cssImports);
  jsx_source = addImports(jsx_source, moduleImports);
  jsx_source = parseRoutes(jsx_source, routesConfig, name);
  dataConnections = parseDataConnections(dataConnections, name);
  var dConns = makeDataConnections(name, dataConnections);
  jsx_source = addDataConns(jsx_source, dConns, name);
  jsx_source = jsx_source.replace(/#__##IMP_START/g, '');
  jsx_source = jsx_source.replace(/#__##ROUTE_IMP/g, '');
  jsx_source = jsx_source.replace(/#__##ACT_START/g, '');
  return _prettier.default.format(jsx_source, _common.prettierConf);
}

module.exports = phnxAppLoader;