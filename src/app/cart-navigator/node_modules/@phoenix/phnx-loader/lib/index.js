'use strict';
/**
 * This file is a loader for webpack to convert the phnx
 * to javascript definition so that it gets bundled along
 * with the application
 *
 * @param  {string} source Entire phnx file as string
 * @return {string}        Stringified javascriot output
 *
 * @author Aftab Khan
 * @date 20-07-2016
 */

var _expectStructure = _interopRequireDefault(require("./helpers/expect-structure"));

var _common = require("./helpers/common");

var _prettier = _interopRequireDefault(require("prettier"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var localTemplates;
var importedComps = [];
var existenceBooleans;
/* -------------------------- STATEMENT GENERATORS ----------------------------*/

/**
 * Function to add initial barebones of the class to the source string
 * @param  {string}  name        Name of the class
 * @param  {string}  includesDef Path of the definition that you want this to extend
 * @return {string}  			 The barebones of the class as source string
 */

var getInitialBarebones = function getInitialBarebones(name, fromTest, includesDef, needPhnxUtils, needGlobalEvents, needLoadable) {
  return "\nimport BaseComponent, {createComponent, connectComponent, createElement} from '@phoenix/phnx-loader/lib/helpers/base-component';\n".concat(fromTest ? "import {generateDummyWithFns} from '@phoenix/phnx-test/lib/jest-helpers/DummyComponent';" : '', "\n#__##SECRET_REMOVE_STARTimport * as secret_utils from '@phoenix/phnx-utils';#__##SECRET_REMOVE_END\n").concat(needPhnxUtils ? "import * as phnxUtils from '@phoenix/phnx-utils/lib/user-utils/frameworkUtils';" : '', "\n").concat(needGlobalEvents ? "const GlobalEvents = require('@phoenix/phnx-utils/lib/global-events');" : '', "\n").concat(needLoadable ? "import Loadable from '@phoenix/phnx-loader/lib/helpers/loadable';" : '', "\nconst defaults = require('").concat(includesDef, "');\nBaseComponent.prototype = Object.assign(BaseComponent.prototype, defaults);\n#__##IMP_START\n#__##CONSTAREA\nconst meta = {\n\tmetadata,\n\tmodelVariables: #__##MODELVARS,\n\tsetContext: #__##SETCONTXT,\n\tgetContext: #__##USECONTXT,\n\tapis: #__##COMP_APIS,\n\tbaseApis: Object.keys(defaults),\n\tfinalDefVarMap: Object.assign({}, defaults.varMap, #__##DEFVARMAP),\n\tevents: #__##COMP_EVTS\n};\n\nclass ").concat(name, " extends BaseComponent {\n\tconstructor(props) {\n\t\tsuper(props);\n\t\tthis.__finalEventMap = {};\n\t\tthis.__userAddedEvents = {};\n\t\t#__##DAT_START\n\t}\n\n\t#__##CONTEXTFN\n\n\t#__##LIFESTART\n\n\t#__##FUN_START\n\n\trender = () => {\n\t\treturn( #__##RENDERRET );\n\t}\n}\n\nconst NonConnectedComp = createComponent(").concat(name, ", '").concat(name, "', meta);\nexport {NonConnectedComp as Test").concat(name, "};\n").concat(fromTest ? "export default generateDummyWithFns(meta.apis);" : "export default connectComponent(NonConnectedComp, '".concat(name, "', meta);"));
};
/**
 * Function to add all the import statements to the component
 * @param  {string} jsx_source    Current source string
 * @param  {array } imports  	  The array of import objects defined in phnx class
 * @return {string} 			  The source string after imports addition
 */


function addImports(jsx_source, imports) {
  var ret_str = jsx_source;
  imports.reverse().forEach(function (item) {
    var statement = '';

    switch (item.type) {
      case 'module':
        var take = item.take;

        if (typeof take === 'string') {
          statement = "import { ".concat(take, " } from '").concat(item.from, "'; ");
        } else if (_typeof(take) === 'object' && !(take instanceof Array)) {
          if (take.what === '*') {
            statement = "import * as ".concat(take.as, " from '").concat(item.from, "'; ");
          } else if (take.what === 'default') {
            statement = "import ".concat(take.as, " from '").concat(item.from, "'; ");
          } else {
            statement = "import { ".concat(take.what, " as ").concat(take.as, " } from '").concat(item.from, "'; ");
          }
        } else if (take instanceof Array && take.length > 0) {
          statement = 'import {';
          take.forEach(function (obj) {
            if (typeof obj === 'string') {
              statement += "".concat(obj, ", ");
            } else if (_typeof(obj) === 'object' && !(obj instanceof Array)) {
              if (obj.what === '*' || obj.what === 'default') {
                throw new TypeError("The imports cannot have ".concat(obj.what, " inside an array"));
              }

              statement += "".concat(obj.what, " as ").concat(obj.as, ", ");
            } else {
              throw new TypeError("The array of imports has to have either objects or string");
            }
          });
          statement = statement.replace(/,?\s*$/, '}');
          statement += " from '".concat(item.from, "'; ");
        }

        break;

      case 'component':
        importedComps.push(item.take);

        if (item.hasOwnProperty('lazyLoad') && item.lazyLoad === true) {
          statement = "const ".concat(item.take, " = Loadable({loader: () => import( /* webpackChunkName: \"").concat(item.take, "\" */ '").concat(item.from, "')}); ");
        } else {
          statement = "import ".concat(item.take, " from '").concat(item.from, "'; ");
        }

        break;

      case 'asset':
        statement = "const ".concat(item.take, " = require('").concat(item.from, "'); ");
        break;

      case 'css':
        statement = "require('".concat(item.from, "'); ");
        break;

      case 'script':
        if (/^https?:\/\//.test(item.from)) {
          statement = "require('scriptjs')('".concat(item.from, "'); ");
        } else {
          statement = "require('!!script-loader!".concat(item.from, "'); ");
        }

        break;

      default:
        break;
    }

    ret_str = (0, _common.doReplace)(ret_str, '#__##IMP_START', statement);
  });
  return ret_str;
}
/**
 * This function adds the members for the component being created
 * @param  {string}  jsx_source       Current source string
 * @param  {array}   variables        Class variables/Props meta
 * @param  {array}   useProtectedVars Array of protected variable names that will be used here
 * @return {string}  				  The source string after variables addition
 */


function addVariables(jsx_source, variables, useProtectedVars) {
  var ret_str = jsx_source;
  var varTypeMap = {};
  var modelVariables = {};
  var contextVars = {};
  var compDefaults = 'this.__compDefaults = {';
  var compPropDefaults = 'this.__compPropDefaults = {';
  var validators = 'this.__extVarValidations = { ';
  var extVarTypeMeta = [];
  useProtectedVars.forEach(function (item) {
    varTypeMap[item] = {
      scope: 'protected'
    };
  });
  variables.forEach(function (item) {
    if (varTypeMap[item.name] !== undefined) {
      throw new Error("Variable ".concat(item.name, " is duplicate"));
    }

    if (item.scope !== 'protected') {
      varTypeMap[item.name] = {
        scope: item.scope,
        mergeProps: item.properties || {}
      };
    }

    switch (item.scope) {
      case 'model':
        modelVariables[item.name] = item.defaultValue;
        break;

      case 'private':
        compDefaults += item.name + ': ' + parseDefaultValues(item.defaultValue) + ', ';
        break;

      case 'protected':
        contextVars[item.name] = parseDefaultValues(item.defaultValue);
        break;

      case 'public':
        if (item.type === undefined) {
          throw new Error('Variable type has to be defined for external variable ' + item.name);
        }

        if (item.metadata && _typeof(item.metadata) === 'object') {
          if (item.metadata instanceof Array) {
            extVarTypeMeta = extVarTypeMeta.concat(item.metadata);
          } else {
            extVarTypeMeta.push(item.metadata);
          }
        }

        if (item.validatorFn) {
          validators += item.name + ' : ' + new String(item.validatorFn) + ', ';
        }

        compPropDefaults += item.name + ': ' + parseDefaultValues(item.defaultValue) + ', ';
        break;

      default:
        break;
    }
  });
  compDefaults = compDefaults.replace(/,?\s*$/, '};');
  compPropDefaults = compPropDefaults.replace(/,?\s*$/, '};');
  validators = validators.replace(/,?\s*$/, '};'); // FUTURE: See if we can remove this. And resolvePrefixes from index.js

  var statement = 'this.varTypeMap = ' + JSON.stringify(varTypeMap) + '; ';
  ret_str = (0, _common.doReplace)(ret_str, '#__##DAT_START', statement);
  statement = '\nconst metadata = ' + JSON.stringify(extVarTypeMeta) + '; ';
  ret_str = (0, _common.doReplace)(ret_str, '#__##CONSTAREA', statement);
  ret_str = (0, _common.doReplace)(ret_str, '#__##DAT_START', compDefaults);
  ret_str = (0, _common.doReplace)(ret_str, '#__##DAT_START', compPropDefaults);
  ret_str = (0, _common.doReplace)(ret_str, '#__##DAT_START', validators);
  ret_str = (0, _common.doReplace)(ret_str, '#__##MODELVARS', (0, _common.funcStringify)(modelVariables));
  var contextKeys = Object.keys(contextVars);
  ret_str = (0, _common.doReplace)(ret_str, '#__##SETCONTXT', JSON.stringify(contextKeys));

  if (contextKeys.length > 0) {
    var _statement = "getChildContext() {\n\treturn ".concat((0, _common.funcStringify)(contextVars), ";\n}");

    ret_str = (0, _common.doReplace)(ret_str, '#__##CONTEXTFN', _statement);
  }

  return ret_str;
}
/**
 * This function is used to parse the default values on the variables
 * @param  {any} defVal Variable to pass
 * @return {any}        Parsed variable
 */


function parseDefaultValues(defVal) {
  var toReturn = JSON.stringify(defVal);

  if (toReturn !== undefined) {
    toReturn = toReturn.replace(/"[^"]*(__wf__|__fn__|__imports__)[^"]*"/g, function (matched) {
      return resolvePrefixes(matched.substr(1, matched.length - 2), {
        isConstructor: true
      });
    });
  }

  return toReturn;
}
/**
 * This function will create a map of the refs to events to event handlers
 * @param  {string} jsx_source    The current jsx source
 * @param  {array } eventHandlers The array of eventHandler objects
 * @param  {array } eventEmitters The array of eventEmitter objects
 * @param  {array}  actions       This will contain array of action defs
 * @return {string}               The source after adding the map
 */


function parseEvents(jsx_source, eventHandlers, eventEmitters, actions) {
  var ret_str = jsx_source;
  var eventMap = {};
  eventHandlers.forEach(function (item) {
    if (item.from === null) {
      throw new Error("Event Handlers from cannot be null in ".concat(item.id));
    } else {
      Object.keys(item.from).forEach(function (elem) {
        var elemEvt = item.from[elem];

        if (eventMap[elem] && eventMap[elem][elemEvt]) {
          throw new Error("Event ".concat(elemEvt, " from element with id ").concat(elem, " is duplicate"));
        } else {
          if (!eventMap[elem]) {
            eventMap[elem] = {};
          }

          eventMap[elem][elemEvt] = {
            type: 'wf',
            value: item.workflow
          };
        }
      });
    }
  });
  var emittedEvents = [];
  eventEmitters.forEach(function (item) {
    //Here from is optional as evt can be programmatically used too
    if (item.from) {
      Object.keys(item.from).forEach(function (elem) {
        var elemEvt = item.from[elem];

        if (eventMap[elem] && eventMap[elem][elemEvt]) {
          throw new Error("Event ".concat(elemEvt, " from element with id ").concat(obj, " is duplicate"));
        } else {
          if (!eventMap[elem]) {
            eventMap[elem] = {};
          }

          eventMap[elem][elemEvt] = {
            type: 'evt',
            value: item.emit
          };
        }
      });
    }

    emittedEvents = emittedEvents.concat(Object.keys(item.emit));
  });
  var actionMap = {};
  actions.forEach(function (item) {
    var id = item.id;

    if (actionMap.hasOwnProperty(id)) {
      throw new Error("The id ".concat(id, " given to the actions is expected to be unique"));
    }

    if (item.type === 'CALL') {
      var evalString = new String(item.body);
      item.body = resolvePrefixes(evalString, {});
    } else if (item.type === 'TARGETS') {
      var update = item.update || {};
      var newUpdate = {};
      Object.keys(update).forEach(function (variable) {
        var variableVal = update[variable];

        if (variableVal === null) {
          variableVal = {};
        } else if (variableVal.payloadModifier) {
          var _evalString = new String(variableVal.payloadModifier);

          variableVal.payloadModifier = resolvePrefixes(_evalString, {});
        }

        newUpdate[variable] = variableVal;
      });
      item.update = newUpdate;
    }

    actionMap[id] = item;
  });
  var statement = '\n#__##EVTMAP_REMOVE_STARTconst phnxEventMap = ' + JSON.stringify(eventMap) + '; #__##EVTMAP_REMOVE_END';
  ret_str = (0, _common.doReplace)(ret_str, '#__##CONSTAREA', statement);
  statement = 'this.__actionMap = ' + (0, _common.funcStringify)(actionMap) + '; ';
  ret_str = (0, _common.doReplace)(ret_str, '#__##DAT_START', statement);
  ret_str = (0, _common.doReplace)(ret_str, '#__##COMP_EVTS', JSON.stringify(emittedEvents));
  return ret_str;
}
/**
 * This function adds all the member functions to the class
 * @param {string}  jsx_source      Current JSX_source
 * @param {object}  functions       Object of functions that is created by you
 * @param {object}  workflows       Object of workflows that is created by you
 * @param {object}  lifecycleHooks  Object of lifecycle functions
 */


function addFunctions(jsx_source, functions, workflows, lifecycleHooks) {
  //Every object that we are inserting into, last item has a trailing comma
  var ret_str = jsx_source;
  var apis = Object.keys(functions);
  ret_str = (0, _common.doReplace)(ret_str, '#__##COMP_APIS', JSON.stringify(apis));
  apis.forEach(function (fn) {
    ret_str = (0, _common.doReplace)(ret_str, '#__##DAT_START', "this.".concat(fn, " = this.").concat(fn, ".bind(this);\n"));
  });
  apis.forEach(function (item) {
    var evalString = functions[item];
    evalString = resolveText(evalString, false);
    evalString = evalString.replace(/(^\s*\(\s*function\s*|\)\s*$)/g, '');
    var statement = "".concat(evalString, "\n");
    ret_str = (0, _common.doReplace)(ret_str, '#__##FUN_START', statement);
  });
  var wfs = Object.keys(workflows);
  wfs.forEach(function (wf) {
    ret_str = (0, _common.doReplace)(ret_str, '#__##DAT_START', "this.wf_".concat(wf, " = this.wf_").concat(wf, ".bind(this);\n"));
  });
  wfs.forEach(function (item) {
    var evalString = workflows[item];
    evalString = resolvePrefixes(evalString, {
      isWorkflow: true
    });
    evalString = evalString.replace(/(^\s*\(\s*function\s*|\)\s*$)/g, '');
    var statement = "".concat(evalString, "\n");
    ret_str = (0, _common.doReplace)(ret_str, '#__##FUN_START', statement);
  });
  ret_str = parseLifecycleHooks(ret_str, 'componentWillUnmount', lifecycleHooks.cleanup);

  function replacement(lifecycle, got, c1, c2) {
    if (c2 === undefined) {
      c2 = c1.split(',')[0];
    }

    c2 = c2.trim();

    if (c2 !== '') {
      existenceBooleans.secret_utils = true;
    }

    return "".concat(got, " ").concat(lifecycle === 'shouldComponentUpdate' ? 'const orig = ' : '', "defaults.").concat(lifecycle, ".apply(this, arguments);").concat(c2 === '' ? '' : "\n\t\t".concat(c2, " = secret_utils.makePropsCopy.apply(this, arguments);"));
  }

  var replacementRegexp = /(?:\s*\(([^\)]*)\)\s*=>\s*{|\s*([A-Za-z0-9_]*)\s*=>\s*{)/;
  /*The code snippet to clear the event mapping of the removed components*/

  if (lifecycleHooks.reRender && lifecycleHooks.reRender.after) {
    var cdu = lifecycleHooks.reRender.after;
    cdu = cdu.replace(replacementRegexp, replacement.bind(null, 'componentDidUpdate'));
    ret_str = parseLifecycleHooks(ret_str, 'componentDidUpdate', cdu);
  }

  if (lifecycleHooks.reRender && lifecycleHooks.reRender.before) {
    var cwu = lifecycleHooks.reRender.before;
    cwu = cwu.replace(replacementRegexp, replacement.bind(null, 'componentWillUpdate'));
    ret_str = parseLifecycleHooks(ret_str, 'componentWillUpdate', cwu);
  }
  /*The code snippet to control re-render of the components*/


  if (lifecycleHooks.reRender && lifecycleHooks.reRender.shouldAllow) {
    var scu = lifecycleHooks.reRender.shouldAllow;
    scu = scu.replace(replacementRegexp, replacement.bind(null, 'shouldComponentUpdate')); //This will also replace within strings also

    scu = scu.replace(/(return )/g, '$1 orig && ');
    ret_str = parseLifecycleHooks(ret_str, 'shouldComponentUpdate', scu);
  }
  /*Validations for incoming vars*/


  if (lifecycleHooks.onModelChange) {
    var cwrp = lifecycleHooks.onModelChange;
    cwrp = cwrp.replace(replacementRegexp, replacement.bind(null, 'componentWillReceiveProps'));
    ret_str = parseLifecycleHooks(ret_str, 'componentWillReceiveProps', cwrp);
  }

  if (lifecycleHooks.init) {
    /*Invoke validation even for the first time*/
    if (lifecycleHooks.init.after) {
      var cdm = lifecycleHooks.init.after;
      cdm = cdm.replace(/(\s*\([^\)]*\)\s*=>\s*{|\s*[A-Za-z0-9_]*\s*=>\s*{)/, "$1 defaults.componentWillReceiveProps.call(this, this.props); ");
      ret_str = parseLifecycleHooks(ret_str, 'componentDidMount', cdm);
    }
    /*Applying defaults for the first time*/


    if (lifecycleHooks.init.before) {
      var cwm = lifecycleHooks.init.before;
      cwm = cwm.replace(/(\s*\([^\)]*\)\s*=>\s*{|\s*[A-Za-z0-9_]*\s*=>\s*{)/, "$1 defaults.componentWillMount.call(this); ");
      ret_str = parseLifecycleHooks(ret_str, 'componentWillMount', cwm);
    }
  }

  return ret_str;
}
/**
 * This function parses function definition and converts it
 * into string and inserts in appropriate place
 * @param  {string}   ret_str     The current JSX source
 * @param  {string}   funcName    Name of the function
 * @param  {function} functionObj The function's definition
 */


function parseLifecycleHooks(ret_str, funcName, functionObj) {
  if (functionObj === null || functionObj === undefined) {
    return ret_str;
  }

  var evalString = functionObj;
  evalString = resolvePrefixes(evalString, {});
  evalString = evalString.replace(/(?:\s*\(([^\)]*)\)\s*=>\s*{|\s*([A-Za-z0-9_]*)\s*=>\s*{)/, function (got, c1, c2) {
    return "function(".concat(c1 !== undefined ? c1 : c2, ") {");
  });
  var statement = '\n' + funcName + ' = ' + evalString + ' \n';
  return (0, _common.doReplace)(ret_str, '#__##LIFESTART', statement);
}
/**
 * Function to recurse through the structure creating individual elements
 * @param {string}  jsx_source  The current source
 * @param {object}  structure   The JSON object
 */


function addJSX(jsx_source, structure) {
  var ret_str = jsx_source;
  var statement = recursiveParser(structure);
  ret_str = (0, _common.doReplace)(ret_str, '#__##RENDERRET', statement);
  return ret_str;
}
/* -------------------------- HELPER FUNCTIONS ----------------------------*/

/**
 * This function replaces prefixes on the prop values
 * @param  {string}        evalString  Any string with allowed prefixes
 * @param  {object}        configObj   Configuration for the replace function
 * @return {string/object}             Replaced output
 *
 * Note: Make sure you update stuff in phnxDefLoader
 */


function resolvePrefixes(evalString, _ref) {
  var _ref$replaceStatus = _ref.replaceStatus,
      replaceStatus = _ref$replaceStatus === void 0 ? false : _ref$replaceStatus,
      _ref$isConstructor = _ref.isConstructor,
      isConstructor = _ref$isConstructor === void 0 ? false : _ref$isConstructor,
      _ref$isWorkflow = _ref.isWorkflow,
      isWorkflow = _ref$isWorkflow === void 0 ? false : _ref$isWorkflow;
  var ret_str = evalString;
  var replaced = false; //__elId__ can be used inside anything that goes as member function or lifecycle hook for the component

  if (ret_str.search(/(__var__|__utils__|__evt__|__act__|__appModel__|__fn__|__prop__|__elId__|__fnParam__|__imports__|__wf__)/) !== -1) {
    ret_str = ret_str.replace(/__var__(?:([A-Za-z0-9_]+)|\[([A-Za-z0-9_\'\"]+)\])/g, function (got, s1, s2) {
      if (s1 !== undefined) {
        return "secret_utils.getVariable.call(this, '".concat(s1, "')");
      }

      return "secret_utils.getVariable.call(this, ".concat(s2, ")");
    });
    ret_str = ret_str.replace(/__wf__/g, 'this.wf_');

    if (isWorkflow) {
      ret_str = ret_str.replace(/__evt__([A-Za-z0-9_]+)/g, 'this.props.$1 && this.props.$1');
      ret_str = ret_str.replace(/__act__([A-Za-z0-9_]+)\s*\(\s*\)/g, "secret_utils.runMyAction.call(this, '$1')");
      ret_str = ret_str.replace(/__act__([A-Za-z0-9_]+)\s*\(/g, "secret_utils.runMyAction.call(this, '$1', "); //Emitting events should be allowed only inside wf

      ret_str = ret_str.replace(/__utils__emitEvent\(/g, 'phnxUtils.emitEvent.call(this, ');
    }

    ret_str = ret_str.replace(/(__imports__|__fnParam__)/g, ''); //FUTURE: Make sure any function from utils is a function call NOT ASSIGNMENT

    ret_str = ret_str.replace(/__utils__RouteLink/g, 'phnxUtils.RouteLink');

    if (/__utils__emitEvent/.test(ret_str)) {
      throw new Error("Can't use emit event outside a workflow");
    }

    ret_str = ret_str.replace(/__utils__([A-Za-z0-9_]+)\s*\(\s*\)/g, 'phnxUtils.$1.call(this)');
    ret_str = ret_str.replace(/__utils__([A-Za-z0-9_]+)\s*\(/g, 'phnxUtils.$1.call(this, ');
    ret_str = ret_str.replace(/__utils__/g, 'phnxUtils.');
    ret_str = ret_str.replace(/__fn__\b/g, 'this');
    ret_str = ret_str.replace(/__fn__/g, 'this.');
    ret_str = ret_str.replace(/(?:__elId__([A-Za-z0-9_]+)|__elId__\[([^\]]*)\])/g, function (got, c1, c2) {
      if (c1 === undefined) return "phnxUtils.getComponentByRef.call(this, ".concat(c2, ")");
      return "phnxUtils.getComponentByRef.call(this, '".concat(c1, "')");
    });
    ret_str = ret_str.replace(/__elId__\b/g, 'this.refs');

    if (isConstructor) {
      ret_str = ret_str.replace(/__prop__\b/g, 'props');
      ret_str = ret_str.replace(/__prop__/g, 'props.');
    } else {
      ret_str = ret_str.replace(/__prop__\b/g, 'this.props');
      ret_str = ret_str.replace(/__prop__/g, 'this.props.');
    }

    ret_str = ret_str.replace(/__appModel__\b/g, 'this.props.__appModel');
    ret_str = ret_str.replace(/__appModel__/g, 'this.props.__appModel.');
    replaced = true;
  }

  if (replaceStatus) {
    return {
      ret_str: ret_str,
      replaced: replaced
    };
  } else {
    return ret_str;
  }
}
/**
 * This function handles parsing of text
 * It can be plain string or call to Render helpers
 * @param  {string}  str             Input string
 * @param  {string}  isFromChildren  Boolean to control how the text is returned
 * @return {string}                  Returns string
 */


function resolveText(str, isFromChildren) {
  isFromChildren = isFromChildren || false;
  var isString = true;
  var evalString = new String(str);

  while (evalString.search(/__tmpl__/) !== -1) {
    var lcomp = evalString.match(/__tmpl__[A-Za-z0-9_]+/)[0];
    var getCompData = localTemplates[lcomp.substr(8)];

    if (getCompData === undefined) {
      throw new Error('Local component not defined ' + lcomp.substr(8));
    }

    var statement = recursiveParser(getCompData);
    evalString = evalString.replace(lcomp, statement);
    isString = false;
  }

  var evalReturn = resolvePrefixes(evalString, {
    replaceStatus: true
  });

  if (isFromChildren && isString && !evalReturn.replaced) {
    return "'" + evalReturn.ret_str + "'";
  } else {
    return evalReturn.ret_str;
  }
}
/**
 * This function removes all the placeholders added in the backbone
 * @param  {string} jsx_source Current Source
 * @return {string}            Cleaned Source
 */


function cleanupSource(jsx_source) {
  var ret_str = jsx_source;
  ret_str = ret_str.replace('#__##MODELVARS', '');
  ret_str = ret_str.replace('#__##CONSTAREA', '');
  ret_str = ret_str.replace('#__##COMP_APIS', '');
  ret_str = ret_str.replace('#__##IMP_START', '');
  ret_str = ret_str.replace('#__##DAT_START', '');
  ret_str = ret_str.replace('#__##LIFESTART', '');
  ret_str = ret_str.replace('#__##FUN_START', '');
  ret_str = ret_str.replace('#__##EVT_START', '');
  ret_str = ret_str.replace('#__##RENDERRET', '');
  ret_str = ret_str.replace('#__##DEFVARMAP', '');
  ret_str = ret_str.replace('#__##COMP_EVTS', '');
  ret_str = ret_str.replace('#__##CONTEXTFN', '');
  ret_str = ret_str.replace('#__##SETCONTXT', '');
  ret_str = ret_str.replace('#__##USECONTXT', '');

  if (existenceBooleans.secret_utils) {
    ret_str = ret_str.replace('#__##SECRET_REMOVE_START', '');
    ret_str = ret_str.replace('#__##SECRET_REMOVE_END', '');
  } else {
    ret_str = ret_str.replace(/#__##SECRET_REMOVE_START.*?#__##SECRET_REMOVE_END/, '');
  }

  if (existenceBooleans.phnxEventMap) {
    ret_str = ret_str.replace('#__##EVTMAP_REMOVE_START', '');
    ret_str = ret_str.replace('#__##EVTMAP_REMOVE_END', '');
  } else {
    ret_str = ret_str.replace(/#__##EVTMAP_REMOVE_START.*?#__##EVTMAP_REMOVE_END/, '');
  }

  return ret_str;
}
/**
 * This function recursively parses through the structure object creating
 * the components needed in the view
 * @param  {object}  structure   the structure object
 * @return {string}              String representation of the elements
 */


function recursiveParser(structure) {
  var ret_str;
  var isCustomComp = false;

  if (_typeof(structure) === 'object') {
    ret_str = 'createElement( ';
    var ctype = structure.type;
    ctype.replace(/^\s*__imports__([A-Za-z0-9_]*)\s*/, function (s, c1) {
      if (importedComps.indexOf(c1) !== -1) isCustomComp = true;
      return s;
    });
    isCustomComp = structure.hasOwnProperty('isComp') ? structure.isComp : isCustomComp;

    if (ctype.search(/(__imports__|__fnParam__)/) !== -1) {
      //Note: if user specifies an asset import/bad js to type, it'll result in a runtime error
      ret_str += ctype.replace(/(__imports__|__fnParam__)/g, '') + ', ';
    } else if (ctype.search(/__prop__|__fn__|__var__|__utils__/) !== -1) {
      ret_str += resolvePrefixes(ctype, {}) + ', ';
    } else {
      ret_str += "'" + ctype + "', ";
    }

    var key,
        cprops = structure.props;
    var propChangeDisallowed = [];
    var otherModelConnect = '{';

    if (_typeof(cprops) === 'object') {
      Object.keys(cprops).forEach(function (item) {
        if (typeof cprops[item] === 'string' && cprops[item].search(/^\s*'?__otherModel__/) !== -1) {
          var toInsert = resolvePrefixes(cprops[item], {
            replaceStatus: true
          });
          toInsert = toInsert.replaced ? toInsert.ret_str : "'".concat(toInsert.ret_str, "'");
          otherModelConnect += "".concat(item, ": ").concat(toInsert, ", ");
          delete cprops[item];
        } else if (JSON.stringify(cprops[item]).search(/(__var__|__wf__|__appModel__|__fn__|__prop__|__fnParam__|__tmpl__|__imports__)/) !== -1) {
          propChangeDisallowed.push(item);
        }

        if (item === 'key') {
          if (typeof cprops[item] === 'string' && cprops[item].search(/(__var__|__wf__|__appModel__|__fn__|__prop__|__fnParam__|__tmpl__|__imports__)/) !== -1) key = resolvePrefixes(cprops[item], {});else key = "\"".concat(cprops[item], "\"");
        }
      });
    } else if (typeof cprops === 'string') {
      propChangeDisallowed.push('__allPropsChange');
    }

    otherModelConnect = otherModelConnect.replace(/,?\s*$/, '}');
    var tmpProps = cprops ? JSON.stringify(cprops) : '{}';
    tmpProps = tmpProps.replace(/"[^"]*(__var__|__wf__|__appModel__|__fn__|__prop__|__fnParam__|__tmpl__|__imports__)[^"]*"/g, function (matched) {
      return resolveText(matched.substr(1, matched.length - 2), true);
    }); //NOTE: Id will be auto-filled by the IDE, on visual selection of that component for event mapping

    var currRef = structure.id;

    if (/__fnParam__/.test(currRef)) {
      currRef = resolvePrefixes(currRef, {});
      existenceBooleans.phnxEventMap = true;
      existenceBooleans.secret_utils = true;
    } else if (currRef !== undefined && currRef !== null) {
      currRef = "'".concat(currRef, "'");
      existenceBooleans.phnxEventMap = true;
      existenceBooleans.secret_utils = true;
    } //initializing local vars. DO NOT PASS Initializers for external variables, it will be ignored


    if (isCustomComp) {
      var cdefaults = structure.defaults;
      var tmpDefaults = cdefaults ? JSON.stringify(cdefaults) : '{}';
      tmpDefaults = tmpDefaults.replace(/"[^"]*(__var__|__wf__|__appModel__|__fn__|__prop__|__fnParam__|__tmpl__|__imports__)[^"]*"/g, function (matched) {
        return resolveText(matched.substr(1, matched.length - 2), true);
      }); //NOTE: If props is directly prefixed string, it returns a special object(String, Boolean, Number) based on the type of the
      //value that it resolved to.

      tmpProps = "Object.assign({".concat(key ? 'key: ' + key : '', "}, {__dontChange: ").concat(JSON.stringify(propChangeDisallowed), ", __passedProps: ").concat(tmpProps, ", __appName: this.props.__appName, __appModel: this.props.__appModel, __passedDefaults: ").concat(tmpDefaults, ", __otherModel: ").concat(otherModelConnect, "} ").concat(currRef ? ", {ref: ".concat(currRef, ", id: ").concat(currRef, "}, secret_utils.getMyEvents.call(this, ").concat(currRef, ", phnxEventMap)") : '', ")");
    } else {
      tmpProps = "Object.assign({".concat(key ? 'key: ' + key : '', "}, ").concat(tmpProps, " ").concat(currRef ? ", {ref: ".concat(currRef, ", id: ").concat(currRef, "}, secret_utils.getMyEvents.call(this, ").concat(currRef, ", phnxEventMap)") : '', ")");
    }

    tmpProps += ',';
    ret_str += tmpProps;
    var cchildren = structure.children;
    var child_str = '';

    if (cchildren !== undefined && cchildren !== null) {
      if (_typeof(cchildren) === 'object') {
        if (cchildren instanceof Array) {
          child_str = ' ';
          cchildren.forEach(function (item) {
            if (typeof item === 'string') {
              child_str += resolveText(item, true) + ', ';
            } else {
              child_str += recursiveParser(item) + ', ';
            }
          });
          child_str = child_str.replace(/,\s*$/, '');
          child_str += ', ';
        } else {
          child_str += recursiveParser(cchildren) + ', ';
        }
      } else if (typeof cchildren === 'string') {
        child_str += resolveText(cchildren, true) + ', ';
      }
    }

    ret_str += child_str;
    ret_str = ret_str.replace(/,\s*$/, ' ) ');
  } else if (typeof structure === 'string') {
    ret_str = resolveText(structure, true);
  }

  return ret_str;
}
/* --------------------------- Loader function -----------------------------*/

/**
 * The loader function
 * @param  {string} source The JSON data as string
 * @return {string}        The javascript corresponding to that JSON
 * @AWESOMENESS +(string) will eval that string
 */


function phnxLoader(source, dontCare, fromTest) {
  fromTest = !!fromTest; //Reset global variables

  importedComps = [];
  existenceBooleans = {
    phnxEventMap: false,
    secret_utils: false
  };
  var needPhnxUtils = /(__utils__|__elId__)/.test(source);
  existenceBooleans.secret_utils = /(__var__|__act__)/.test(source);
  var needGlobalEvents = /GlobalEvents/.test(source); //This will include the import even if you write the string inside a comment!
  //Gets the module.exports from each file

  var compData = this.exec(source, this.resourcePath);
  /* Validate Structure */

  (0, _expectStructure.default)(compData, 'phnx', this.resourcePath);
  /*Get all the non-element data*/

  var name = compData.name;

  if (/^\s*$/.test(name)) {
    throw new Error('Name cannot be empty');
  }

  name = name.charAt(0).toUpperCase() + name.substr(1);

  if (name === 'Connect') {
    throw new Error('Cannot use name Connect for the file');
  } //Add this to dependency using this.addDependency() - for cacheable


  var includesDef = compData.includesDef || '@phoenix/phnx-loader/lib/base-def';
  var useProtectedVars = compData.useProtectedVars || [];
  var defVarMap = compData.defVarMap || {};
  var imports = compData.imports || [];
  var variables = compData.variables || [];
  var actions = compData.actions || [];
  var workflows = compData.workflows || {};
  var functions = compData.functions || {};
  var eventHandlers = compData.eventHandlers || [];
  var eventEmitters = compData.eventEmitters || [];
  localTemplates = compData.localTemplates || {};
  var structure = compData.structure; //Advanced usage of the component

  var lifecycleHooks = compData.lifecycleHooks || {};
  /* Create the JSX strings from the data*/

  var needLoadable = imports.some(function (item) {
    return item.type === 'component' && item.lazyLoad === true;
  });
  var jsx_source = getInitialBarebones(name, fromTest, includesDef, needPhnxUtils, needGlobalEvents, needLoadable);
  jsx_source = (0, _common.doReplace)(jsx_source, '#__##DEFVARMAP', JSON.stringify(defVarMap));
  jsx_source = (0, _common.doReplace)(jsx_source, '#__##USECONTXT', JSON.stringify(useProtectedVars));
  jsx_source = addImports(jsx_source, imports);
  jsx_source = addVariables(jsx_source, variables, useProtectedVars); //Parse the eventHandlers and eventEmitters

  jsx_source = parseEvents(jsx_source, eventHandlers, eventEmitters, actions);
  jsx_source = addFunctions(jsx_source, functions, workflows, lifecycleHooks);
  jsx_source = addJSX(jsx_source, structure);
  jsx_source = cleanupSource(jsx_source);
  return _prettier.default.format(jsx_source, _common.prettierConf);
}

module.exports = phnxLoader;