"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createComponent = createComponent;
exports.connectComponent = connectComponent;
exports.renderDOM = exports.createElement = exports.default = void 0;

var _react = _interopRequireDefault(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _reactDom = require("react-dom");

var _reactRedux = require("react-redux");

var _dataManager = _interopRequireDefault(require("@phoenix/phnx-utils/lib/data-manager"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _default =
/*#__PURE__*/
function (_React$Component) {
  _inherits(_default, _React$Component);

  function _default() {
    _classCallCheck(this, _default);

    return _possibleConstructorReturn(this, (_default.__proto__ || Object.getPrototypeOf(_default)).apply(this, arguments));
  }

  return _default;
}(_react.default.Component);

exports.default = _default;
var createElement = _react.default.createElement;
exports.createElement = createElement;
var renderDOM = _reactDom.render;
/**
 * Function to create the component definition taking care of assigning meta to
 * the class definition. And connecting it to redux state if need be
 * @param  {class }   Component   The definition of the component that user has created
 * @param  {string}   name        Name of the component
 * @param  {object}   meta        Object containing public vars, default props, proptypes
 * @return {class }               The final class needed to be exported from the component
 */

exports.renderDOM = renderDOM;

function createComponent(Component, name, meta) {
  var toFilterArr = ['varMap', 'componentWillMount', 'componentDidMount', 'componentWillReceiveProps', 'shouldComponentUpdate', 'componentWillUpdate', 'componentDidUpdate', 'componentWillUnmount'];
  Component.apis = Array.prototype.concat(meta.apis, meta.baseApis.filter(function (item) {
    return toFilterArr.indexOf(item) === -1;
  }));
  Component.metadata = meta.metadata;
  Component.finalDefVarMap = meta.finalDefVarMap;
  Component.events = meta.events;
  Component.phnxCompName = name;

  if (meta.setContext.length > 0) {
    var obj = {};
    meta.setContext.forEach(function (item) {
      return obj[item] = _propTypes.default.any;
    });
    Component.childContextTypes = obj;
  }

  if (meta.getContext.length > 0) {
    var _obj = {};
    meta.getContext.forEach(function (item) {
      return _obj[item] = _propTypes.default.any;
    });
    Component.contextTypes = _obj;
  }

  (0, _dataManager.default)(name, meta.modelVariables);
  return Component;
}

function connectComponent(NonConnectedComp, name, meta) {
  var fns = function fns(state, ownProps) {
    var retObj = state[name];

    if (ownProps.__otherModel) {
      var otherModel = {};
      Object.keys(ownProps.__otherModel).forEach(function (item) {
        var val = ownProps.__otherModel[item];

        try {
          otherModel[item] = val.replace(/^\s*__otherModel__/, '').split('.').reduce(function (p, c) {
            return p[c];
          }, state);
        } catch (e) {
          console.error("Unable to retrieve ".concat(val, " in ").concat(name, ". Check how the props for ").concat(name, " are being passed.")); //eslint-disable-line
        }
      });
      retObj.__fetchedModel = otherModel;
    }

    return retObj;
  };

  return (0, _reactRedux.connect)(fns, null, null, {
    withRef: true
  })(NonConnectedComp);
}