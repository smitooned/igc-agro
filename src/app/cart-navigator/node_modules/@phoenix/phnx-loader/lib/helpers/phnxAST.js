"use strict";

/**
 * This function is a plugin to babel's transform function
 * which has to be designed in visitor pattern.
 * https://en.wikipedia.org/wiki/Visitor_pattern
 *
 * Ordering of the plugins: https://babeljs.io/docs/plugins/#plugin-preset-ordering
 *
 * We use it for following
 * - To quote all the functions that are values against some key
 * - To convert all the functions to arrow functions
 *
 * @author Aftab Khan
 * @date 30-01-2017
 */

/**
 * Plugin function
 * @param  {object} babel Babel object
 * @return {object}       Functions to be used for transformation
 */
module.exports = function loaderTransforms(babel) {
  var t = babel.types;

  function toString(node) {
    var ast = t.program([t.expressionStatement(node)]);
    var code = babel.transformFromAst(ast).code;
    code = code.replace(/;\s*$/, '');
    return t.stringLiteral(code);
  }

  function locationToConsider(path) {
    //This should return true for entries in 'functions' and 'workflows' key
    var functionsObj = path.parentPath.parent;

    if (t.isObjectExpression(functionsObj)) {
      var objEntry = path.parentPath.parentPath.parent;
      var name = objEntry.key && (objEntry.key.name || objEntry.key.value);
      return name === 'functions' || name === 'workflows' ? name : false;
    }

    return false;
  }

  function getFunctionName(path, location) {
    var objEntry = path.parent;
    var key = objEntry.key.name || objEntry.key.value;
    key = location === 'workflows' ? 'wf_' + key : key;
    return t.identifier(key);
  }

  return {
    visitor: {
      FunctionExpression: {
        exit: function exit(path) {
          var where = locationToConsider(path);

          if (where && path.node.keepFn !== true) {
            var fnNode = t.FunctionExpression(getFunctionName(path, where), path.node.params, path.node.body, false, false);
            fnNode.keepFn = true;
            path.replaceWith(fnNode);
          } else if (!where) {
            //Conversion to arrow functions
            var arrowFnNode = t.arrowFunctionExpression(path.node.params, path.node.body, false);
            arrowFnNode.convertedToArrow = true;
            path.replaceWith(arrowFnNode);
          }
        }
      },
      ThisExpression: {
        enter: function enter(path) {
          //Converting all this expressions to identifiers so that it won't get translated differently
          path.replaceWith(t.identifier('this'));
        }
      },
      ArrowFunctionExpression: {
        exit: function exit(path) {
          var where = locationToConsider(path);

          if (where) {
            //Conversion to normal functions
            var body = path.node.body;

            if (!t.isBlockStatement(body)) {
              body = t.blockStatement([t.returnStatement(body)]);
            }

            var fnNode = t.FunctionExpression(getFunctionName(path, where), path.node.params, body, false, false);
            fnNode.keepFn = true;
            path.replaceWith(fnNode);
          }
        }
      },
      ObjectProperty: {
        exit: function exit(path) {
          var a = path.getFunctionParent();
          if (t.isArrowFunctionExpression(a) || t.isFunctionExpression(a)) return;
          var node = path.node.value;

          if (t.isArrowFunctionExpression(node) || node.keepFn && t.isFunctionExpression(node)) {
            //Converting the function to strings
            path.node.value = toString(node);
          }
        }
      },
      ObjectExpression: {
        enter: function enter(path) {
          var keys = [];
          path.node.properties.forEach(function (item) {
            var key = item.key.name || item.key.value; //Identifier or string literal

            if (keys.indexOf(key) !== -1) {
              throw new Error("Duplicate declaration of object key ".concat(key));
            } else {
              keys.push(key);
            }
          });
        }
      }
    }
  };
};